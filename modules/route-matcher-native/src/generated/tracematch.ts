// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceFetchProgressCallback,
} from "./tracematch-ffi";
import {
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiReferenceHolder,
  type UniffiRustCallStatus,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterFloat32,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTraitInterfaceCall,
} from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

/**
 * Get conservative section config (fewer sections, higher confidence)
 */
export function conservativeSectionConfig(): SectionConfig {
  return FfiConverterTypeSectionConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_conservative_section_config(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Create a route signature from GPS points.
 */
export function createSignature(
  activityId: string,
  points: Array<GpsPoint>,
): RouteSignature | undefined {
  return FfiConverterOptionalTypeRouteSignature.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_create_signature(
          FfiConverterString.lower(activityId),
          FfiConverterArrayTypeGpsPoint.lower(points),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Create a route signature with custom configuration.
 */
export function createSignatureWithConfig(
  activityId: string,
  points: Array<GpsPoint>,
  config: MatchConfig,
): RouteSignature | undefined {
  return FfiConverterOptionalTypeRouteSignature.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_create_signature_with_config(
          FfiConverterString.lower(activityId),
          FfiConverterArrayTypeGpsPoint.lower(points),
          FfiConverterTypeMatchConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Create signatures from flat coordinate buffers (optimized for TypedArray input).
 * Each track's coords array contains [lat1, lng1, lat2, lng2, ...].
 * This avoids the overhead of deserializing GpsPoint objects.
 */
export function createSignaturesFromFlat(
  tracks: Array<FlatGpsTrack>,
  config: MatchConfig,
): Array<RouteSignature> {
  return FfiConverterArrayTypeRouteSignature.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_create_signatures_from_flat(
          FfiConverterArrayTypeFlatGpsTrack.lower(tracks),
          FfiConverterTypeMatchConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get default configuration.
 */
export function defaultConfig(): MatchConfig {
  return FfiConverterTypeMatchConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_default_config(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get default custom section matching config.
 */
export function defaultCustomSectionMatchConfig(): CustomSectionMatchConfig {
  return FfiConverterTypeCustomSectionMatchConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_default_custom_section_match_config(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get default scale presets for multi-scale detection
 */
export function defaultScalePresets(): Array<ScalePreset> {
  return FfiConverterArrayTypeScalePreset.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_default_scale_presets(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Fetch map data for multiple activities in parallel.
 *
 * This function respects intervals.icu rate limits:
 * - 30 req/s burst limit
 * - 131 req/10s sustained limit
 *
 * Uses connection pooling and parallel fetching for maximum performance.
 * Automatically retries on 429 errors with exponential backoff.
 *
 * The auth_header should be a pre-formatted Authorization header value:
 * - For API key auth: "Basic {base64(API_KEY:key)}"
 * - For OAuth: "Bearer {access_token}"
 */
export function fetchActivityMaps(
  authHeader: string,
  activityIds: Array<string>,
): Array<FfiActivityMapResult> {
  return FfiConverterArrayTypeFfiActivityMapResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_fetch_activity_maps(
          FfiConverterString.lower(authHeader),
          FfiConverterArrayString.lower(activityIds),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Fetch map data with real-time progress callbacks.
 *
 * Same as fetch_activity_maps but calls the progress callback after each
 * activity is fetched, allowing the UI to show real-time progress.
 *
 * The auth_header should be a pre-formatted Authorization header value:
 * - For API key auth: "Basic {base64(API_KEY:key)}"
 * - For OAuth: "Bearer {access_token}"
 */
export function fetchActivityMapsWithProgress(
  authHeader: string,
  activityIds: Array<string>,
  callback: FetchProgressCallback,
): Array<FfiActivityMapResult> {
  return FfiConverterArrayTypeFfiActivityMapResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_fetch_activity_maps_with_progress(
          FfiConverterString.lower(authHeader),
          FfiConverterArrayString.lower(activityIds),
          FfiConverterTypeFetchProgressCallback.lower(callback),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Compare two routes and return match result.
 */
export function ffiCompareRoutes(
  sig1: RouteSignature,
  sig2: RouteSignature,
  config: MatchConfig,
): MatchResult | undefined {
  return FfiConverterOptionalTypeMatchResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_compare_routes(
          FfiConverterTypeRouteSignature.lower(sig1),
          FfiConverterTypeRouteSignature.lower(sig2),
          FfiConverterTypeMatchConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Detect sections at multiple scales with potential section suggestions.
 * This is the flagship entry point for section detection.
 *
 * Returns a MultiScaleSectionResult with:
 * - sections: Confirmed sections (meeting min_activities threshold)
 * - potentials: Suggested sections from 1-2 activity overlaps
 * - stats: Detection statistics
 */
export function ffiDetectSectionsMultiscale(
  activityIds: Array<string>,
  allCoords: Array</*f64*/ number>,
  offsets: Array</*u32*/ number>,
  sportTypes: Array<ActivitySportType>,
  groups: Array<RouteGroup>,
  config: SectionConfig,
): MultiScaleSectionResult {
  return FfiConverterTypeMultiScaleSectionResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_detect_sections_multiscale(
          FfiConverterArrayString.lower(activityIds),
          FfiConverterArrayFloat64.lower(allCoords),
          FfiConverterArrayUInt32.lower(offsets),
          FfiConverterArrayTypeActivitySportType.lower(sportTypes),
          FfiConverterArrayTypeRouteGroup.lower(groups),
          FfiConverterTypeSectionConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Optimized section detection using downsampling and grid partitioning.
 * 20-50x faster than full resolution detection, suitable for mobile devices.
 */
export function ffiDetectSectionsOptimized(
  activityIds: Array<string>,
  allCoords: Array</*f64*/ number>,
  offsets: Array</*u32*/ number>,
  sportTypes: Array<ActivitySportType>,
  config: SectionConfig,
): Array<FrequentSection> {
  return FfiConverterArrayTypeFrequentSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_detect_sections_optimized(
          FfiConverterArrayString.lower(activityIds),
          FfiConverterArrayFloat64.lower(allCoords),
          FfiConverterArrayUInt32.lower(offsets),
          FfiConverterArrayTypeActivitySportType.lower(sportTypes),
          FfiConverterTypeSectionConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Find all sections that exist within a given GPS route.
 *
 * Returns a list of section matches with their positions in the route.
 */
export function ffiFindSectionsInRoute(
  route: Array<GpsPoint>,
  sections: Array<FrequentSection>,
  config: SectionConfig,
): Array<SectionMatch> {
  return FfiConverterArrayTypeSectionMatch.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_find_sections_in_route(
          FfiConverterArrayTypeGpsPoint.lower(route),
          FfiConverterArrayTypeFrequentSection.lower(sections),
          FfiConverterTypeSectionConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Generate a heatmap from route signatures.
 * Uses the simplified GPS traces (~100 points each) for efficient generation.
 */
export function ffiGenerateHeatmap(
  signatures: Array<RouteSignature>,
  activityData: Array<ActivityHeatmapData>,
  config: HeatmapConfig,
): HeatmapResult {
  return FfiConverterTypeHeatmapResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_generate_heatmap(
          FfiConverterArrayTypeRouteSignature.lower(signatures),
          FfiConverterArrayTypeActivityHeatmapData.lower(activityData),
          FfiConverterTypeHeatmapConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Incremental grouping: efficiently add new signatures to existing groups.
 * Only compares new vs existing and new vs new - O(n×m) instead of O(n²).
 */
export function ffiGroupIncremental(
  newSignatures: Array<RouteSignature>,
  existingGroups: Array<RouteGroup>,
  existingSignatures: Array<RouteSignature>,
  config: MatchConfig,
): Array<RouteGroup> {
  return FfiConverterArrayTypeRouteGroup.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_group_incremental(
          FfiConverterArrayTypeRouteSignature.lower(newSignatures),
          FfiConverterArrayTypeRouteGroup.lower(existingGroups),
          FfiConverterArrayTypeRouteSignature.lower(existingSignatures),
          FfiConverterTypeMatchConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Group signatures into route groups.
 */
export function ffiGroupSignatures(
  signatures: Array<RouteSignature>,
  config: MatchConfig,
): Array<RouteGroup> {
  return FfiConverterArrayTypeRouteGroup.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_group_signatures(
          FfiConverterArrayTypeRouteSignature.lower(signatures),
          FfiConverterTypeMatchConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Query the heatmap at a specific location.
 */
export function ffiQueryHeatmapCell(
  heatmap: HeatmapResult,
  lat: /*f64*/ number,
  lng: /*f64*/ number,
): CellQueryResult | undefined {
  return FfiConverterOptionalTypeCellQueryResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_query_heatmap_cell(
          FfiConverterTypeHeatmapResult.lower(heatmap),
          FfiConverterFloat64.lower(lat),
          FfiConverterFloat64.lower(lng),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Recalculate a section's polyline based on its activity traces.
 *
 * Useful when a section's polyline has drifted or is biased.
 */
export function ffiRecalculateSectionPolyline(
  section: FrequentSection,
  config: SectionConfig,
): FrequentSection {
  return FfiConverterTypeFrequentSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_recalculate_section_polyline(
          FfiConverterTypeFrequentSection.lower(section),
          FfiConverterTypeSectionConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Split a section at a specific polyline index.
 *
 * Returns two new sections split at the given index.
 */
export function ffiSplitSectionAtIndex(
  section: FrequentSection,
  splitIndex: /*u32*/ number,
): SplitResult | undefined {
  return FfiConverterOptionalTypeSplitResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_split_section_at_index(
          FfiConverterTypeFrequentSection.lower(section),
          FfiConverterUInt32.lower(splitIndex),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Split a section at a geographic point.
 *
 * Returns two new sections if the point is close enough to the section's polyline.
 */
export function ffiSplitSectionAtPoint(
  section: FrequentSection,
  lat: /*f64*/ number,
  lng: /*f64*/ number,
  maxDistanceMeters: /*f64*/ number,
): SplitResult | undefined {
  return FfiConverterOptionalTypeSplitResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_ffi_split_section_at_point(
          FfiConverterTypeFrequentSection.lower(section),
          FfiConverterFloat64.lower(lat),
          FfiConverterFloat64.lower(lng),
          FfiConverterFloat64.lower(maxDistanceMeters),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get legacy section config (backward compatible single-scale)
 */
export function legacySectionConfig(): SectionConfig {
  return FfiConverterTypeSectionConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_legacy_section_config(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Add activities from flat coordinate buffers.
 * Coordinates are [lat1, lng1, lat2, lng2, ...] for each activity.
 */
export function persistentEngineAddActivities(
  activityIds: Array<string>,
  allCoords: Array</*f64*/ number>,
  offsets: Array</*u32*/ number>,
  sportTypes: Array<string>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_add_activities(
        FfiConverterArrayString.lower(activityIds),
        FfiConverterArrayFloat64.lower(allCoords),
        FfiConverterArrayUInt32.lower(offsets),
        FfiConverterArrayString.lower(sportTypes),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Add a custom section from JSON.
 */
export function persistentEngineAddCustomSection(sectionJson: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_add_custom_section(
          FfiConverterString.lower(sectionJson),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Cancel any running section detection.
 */
export function persistentEngineCancelSectionDetection(): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_cancel_section_detection(
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Remove activities older than the specified retention period.
 *
 * This prevents unbounded database growth by cleaning up old activities.
 * Cascade deletes automatically remove associated GPS tracks, signatures,
 * and match data. Groups and sections are marked for re-computation.
 *
 * # Arguments
 * * `retention_days` - Number of days to retain (0 = keep all, 30-365 for cleanup)
 *
 * # Returns
 * Number of activities deleted, or 0 if retention_days is 0
 */
export function persistentEngineCleanupOldActivities(
  retentionDays: /*u32*/ number,
): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_cleanup_old_activities(
          FfiConverterUInt32.lower(retentionDays),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Clear all persistent engine state.
 */
export function persistentEngineClear(): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_clear(
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Extract the GPS trace for an activity that overlaps with a section polyline.
 * Returns a flat array of [lat, lng, lat, lng, ...] or empty if no overlap.
 */
export function persistentEngineExtractSectionTrace(
  activityId: string,
  sectionPolylineJson: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_extract_section_trace(
          FfiConverterString.lower(activityId),
          FfiConverterString.lower(sectionPolylineJson),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get activity count.
 */
export function persistentEngineGetActivityCount(): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_activity_count(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all activity IDs.
 */
export function persistentEngineGetActivityIds(): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_activity_ids(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all activity bounds info as JSON for map display.
 */
export function persistentEngineGetAllActivityBoundsJson(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_all_activity_bounds_json(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all custom route names as JSON.
 */
export function persistentEngineGetAllRouteNamesJson(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_all_route_names_json(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all custom section names as JSON.
 */
export function persistentEngineGetAllSectionNamesJson(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_all_section_names_json(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get consensus route for a group as flat coordinates.
 */
export function persistentEngineGetConsensusRoute(
  groupId: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_consensus_route(
          FfiConverterString.lower(groupId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get matches for a custom section.
 * Returns JSON array of matches.
 */
export function persistentEngineGetCustomSectionMatches(
  sectionId: string,
): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_custom_section_matches(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all custom sections as JSON.
 */
export function persistentEngineGetCustomSectionsJson(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_custom_sections_json(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get GPS track for an activity as flat coordinates.
 */
export function persistentEngineGetGpsTrack(
  activityId: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_gps_track(
          FfiConverterString.lower(activityId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get route groups as JSON.
 */
export function persistentEngineGetGroupsJson(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_groups_json(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get the custom name for a route.
 * Returns empty string if no custom name is set.
 */
export function persistentEngineGetRouteName(routeId: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_route_name(
          FfiConverterString.lower(routeId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get route performances as JSON.
 */
export function persistentEngineGetRoutePerformancesJson(
  routeGroupId: string,
  currentActivityId: string | undefined,
): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_route_performances_json(
          FfiConverterString.lower(routeGroupId),
          FfiConverterOptionalString.lower(currentActivityId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get current section detection progress.
 * Returns JSON with format: {"phase": "finding_overlaps", "completed": 45, "total": 120}
 * Returns empty JSON "{}" if no detection is running.
 */
export function persistentEngineGetSectionDetectionProgress(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_section_detection_progress(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get the custom name for a section.
 * Returns empty string if no custom name is set.
 */
export function persistentEngineGetSectionName(sectionId: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_section_name(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get section performances as JSON.
 * Returns accurate time-based section traversal data.
 */
export function persistentEngineGetSectionPerformancesJson(
  sectionId: string,
): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_section_performances_json(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get sections as JSON.
 */
export function persistentEngineGetSectionsJson(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_sections_json(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get engine statistics.
 */
export function persistentEngineGetStats(): PersistentEngineStats | undefined {
  return FfiConverterOptionalTypePersistentEngineStats.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_get_stats(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Initialize the persistent engine with a database path.
 * Call this once at app startup before any other persistent engine functions.
 */
export function persistentEngineInit(dbPath: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_init(
          FfiConverterString.lower(dbPath),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Check if the persistent engine is initialized.
 */
export function persistentEngineIsInitialized(): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_is_initialized(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Mark route engine for re-computation.
 *
 * Call this when historical activities are added (e.g., cache expansion)
 * to trigger re-computation of route groups and sections with the new data.
 */
export function persistentEngineMarkForRecomputation(): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_mark_for_recomputation(
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Match a custom section against activities.
 * Returns JSON array of matches.
 */
export function persistentEngineMatchCustomSection(
  sectionId: string,
  activityIds: Array<string>,
): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_match_custom_section(
          FfiConverterString.lower(sectionId),
          FfiConverterArrayString.lower(activityIds),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Poll for section detection completion.
 * Returns:
 * - "running" if detection is still in progress
 * - "complete" if detection finished and sections were applied
 * - "idle" if no detection is running
 * - "error" if detection failed
 */
export function persistentEnginePollSections(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_poll_sections(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Query activities in viewport.
 */
export function persistentEngineQueryViewport(
  minLat: /*f64*/ number,
  maxLat: /*f64*/ number,
  minLng: /*f64*/ number,
  maxLng: /*f64*/ number,
): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_query_viewport(
          FfiConverterFloat64.lower(minLat),
          FfiConverterFloat64.lower(maxLat),
          FfiConverterFloat64.lower(minLng),
          FfiConverterFloat64.lower(maxLng),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Remove activities by ID.
 */
export function persistentEngineRemoveActivities(
  activityIds: Array<string>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_remove_activities(
        FfiConverterArrayString.lower(activityIds),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Remove a custom section.
 */
export function persistentEngineRemoveCustomSection(
  sectionId: string,
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_remove_custom_section(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Set activity metrics for performance calculations.
 */
export function persistentEngineSetActivityMetrics(
  metrics: Array<ActivityMetrics>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_set_activity_metrics(
        FfiConverterArrayTypeActivityMetrics.lower(metrics),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set a custom name for a route.
 * Pass empty string to clear the custom name.
 */
export function persistentEngineSetRouteName(
  routeId: string,
  name: string,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_set_route_name(
        FfiConverterString.lower(routeId),
        FfiConverterString.lower(name),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set a custom name for a section.
 * Pass empty string to clear the custom name.
 */
export function persistentEngineSetSectionName(
  sectionId: string,
  name: string,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_set_section_name(
        FfiConverterString.lower(sectionId),
        FfiConverterString.lower(name),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set time streams for activities from flat buffer.
 * Time streams are cumulative seconds at each GPS point, used for section performance calculations.
 * Parameters:
 * - activity_ids: Vec of activity IDs
 * - all_times: Flat array of all time values concatenated
 * - offsets: Start offset for each activity's times in all_times (length = activity_ids.len() + 1)
 */
export function persistentEngineSetTimeStreamsFlat(
  activityIds: Array<string>,
  allTimes: Array</*u32*/ number>,
  offsets: Array</*u32*/ number>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_set_time_streams_flat(
        FfiConverterArrayString.lower(activityIds),
        FfiConverterArrayUInt32.lower(allTimes),
        FfiConverterArrayUInt32.lower(offsets),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Start section detection in the background.
 * Returns true if detection was started, false if already running or engine not initialized.
 */
export function persistentEngineStartSectionDetection(
  sportFilter: string | undefined,
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_persistent_engine_start_section_detection(
          FfiConverterOptionalString.lower(sportFilter),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Process routes end-to-end from flat buffers: create signatures AND group them.
 * Most efficient way to process many activities from TypedArray input.
 */
export function processRoutesFromFlat(
  tracks: Array<FlatGpsTrack>,
  config: MatchConfig,
): Array<RouteGroup> {
  return FfiConverterArrayTypeRouteGroup.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_tracematch_fn_func_process_routes_from_flat(
          FfiConverterArrayTypeFlatGpsTrack.lower(tracks),
          FfiConverterTypeMatchConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}

/**
 * Callback interface for receiving progress updates during fetch operations.
 * Implement this in TypeScript/Kotlin/Swift to receive real-time updates.
 */
export interface FetchProgressCallback {
  /**
   * Called when a single activity fetch completes.
   * - completed: Number of activities fetched so far
   * - total: Total number of activities to fetch
   */
  onProgress(completed: /*u32*/ number, total: /*u32*/ number): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFetchProgressCallback: {
  vtable: UniffiVTableCallbackInterfaceFetchProgressCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onProgress: (uniffiHandle: bigint, completed: number, total: number) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFetchProgressCallback.lift(uniffiHandle);
        return jsCallback.onProgress(
          FfiConverterUInt32.lift(completed),
          FfiConverterUInt32.lift(total),
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower,
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FetchProgressCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFetchProgressCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_tracematch_fn_init_callback_vtable_fetchprogresscallback(
      uniffiCallbackInterfaceFetchProgressCallback.vtable,
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeFetchProgressCallback =
  new FfiConverterCallback<FetchProgressCallback>();

/**
 * Activity metadata for heatmap generation
 */
export type ActivityHeatmapData = {
  activityId: string;
  routeId: string | undefined;
  routeName: string | undefined;
  timestamp: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link ActivityHeatmapData} record objects.
 */
export const ActivityHeatmapData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ActivityHeatmapData, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ActivityHeatmapData}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ActivityHeatmapData}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ActivityHeatmapData>,
  });
})();

const FfiConverterTypeActivityHeatmapData = (() => {
  type TypeName = ActivityHeatmapData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        routeId: FfiConverterOptionalString.read(from),
        routeName: FfiConverterOptionalString.read(from),
        timestamp: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterOptionalString.write(value.routeId, into);
      FfiConverterOptionalString.write(value.routeName, into);
      FfiConverterOptionalInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterOptionalString.allocationSize(value.routeId) +
        FfiConverterOptionalString.allocationSize(value.routeName) +
        FfiConverterOptionalInt64.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Activity metadata for performance calculations.
 * Stores the non-GPS data needed for performance comparison.
 */
export type ActivityMetrics = {
  activityId: string;
  name: string;
  /**
   * Unix timestamp (seconds since epoch)
   */
  date: /*i64*/ bigint;
  /**
   * Distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Moving time in seconds
   */
  movingTime: /*u32*/ number;
  /**
   * Elapsed time in seconds
   */
  elapsedTime: /*u32*/ number;
  /**
   * Total elevation gain in meters
   */
  elevationGain: /*f64*/ number;
  /**
   * Average heart rate (optional)
   */
  avgHr: /*u16*/ number | undefined;
  /**
   * Average power in watts (optional)
   */
  avgPower: /*u16*/ number | undefined;
  /**
   * Sport type (e.g., "Ride", "Run")
   */
  sportType: string;
};

/**
 * Generated factory for {@link ActivityMetrics} record objects.
 */
export const ActivityMetrics = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ActivityMetrics, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ActivityMetrics}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ActivityMetrics}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ActivityMetrics>,
  });
})();

const FfiConverterTypeActivityMetrics = (() => {
  type TypeName = ActivityMetrics;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        date: FfiConverterInt64.read(from),
        distance: FfiConverterFloat64.read(from),
        movingTime: FfiConverterUInt32.read(from),
        elapsedTime: FfiConverterUInt32.read(from),
        elevationGain: FfiConverterFloat64.read(from),
        avgHr: FfiConverterOptionalUInt16.read(from),
        avgPower: FfiConverterOptionalUInt16.read(from),
        sportType: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.name, into);
      FfiConverterInt64.write(value.date, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterUInt32.write(value.movingTime, into);
      FfiConverterUInt32.write(value.elapsedTime, into);
      FfiConverterFloat64.write(value.elevationGain, into);
      FfiConverterOptionalUInt16.write(value.avgHr, into);
      FfiConverterOptionalUInt16.write(value.avgPower, into);
      FfiConverterString.write(value.sportType, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterInt64.allocationSize(value.date) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterUInt32.allocationSize(value.movingTime) +
        FfiConverterUInt32.allocationSize(value.elapsedTime) +
        FfiConverterFloat64.allocationSize(value.elevationGain) +
        FfiConverterOptionalUInt16.allocationSize(value.avgHr) +
        FfiConverterOptionalUInt16.allocationSize(value.avgPower) +
        FfiConverterString.allocationSize(value.sportType)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Input mapping activity IDs to sport types
 */
export type ActivitySportType = {
  activityId: string;
  sportType: string;
};

/**
 * Generated factory for {@link ActivitySportType} record objects.
 */
export const ActivitySportType = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ActivitySportType, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ActivitySportType}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ActivitySportType}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ActivitySportType>,
  });
})();

const FfiConverterTypeActivitySportType = (() => {
  type TypeName = ActivitySportType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.sportType, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.sportType)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Bounding box for a route.
 */
export type Bounds = {
  minLat: /*f64*/ number;
  maxLat: /*f64*/ number;
  minLng: /*f64*/ number;
  maxLng: /*f64*/ number;
};

/**
 * Generated factory for {@link Bounds} record objects.
 */
export const Bounds = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bounds, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bounds}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bounds}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bounds>,
  });
})();

const FfiConverterTypeBounds = (() => {
  type TypeName = Bounds;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        minLat: FfiConverterFloat64.read(from),
        maxLat: FfiConverterFloat64.read(from),
        minLng: FfiConverterFloat64.read(from),
        maxLng: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.minLat, into);
      FfiConverterFloat64.write(value.maxLat, into);
      FfiConverterFloat64.write(value.minLng, into);
      FfiConverterFloat64.write(value.maxLng, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.minLat) +
        FfiConverterFloat64.allocationSize(value.maxLat) +
        FfiConverterFloat64.allocationSize(value.minLng) +
        FfiConverterFloat64.allocationSize(value.maxLng)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Query result when user taps a location
 */
export type CellQueryResult = {
  /**
   * The cell at the queried location
   */
  cell: HeatmapCell;
  /**
   * Suggested label based on patterns
   */
  suggestedLabel: string;
};

/**
 * Generated factory for {@link CellQueryResult} record objects.
 */
export const CellQueryResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CellQueryResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CellQueryResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CellQueryResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CellQueryResult>,
  });
})();

const FfiConverterTypeCellQueryResult = (() => {
  type TypeName = CellQueryResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        cell: FfiConverterTypeHeatmapCell.read(from),
        suggestedLabel: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeHeatmapCell.write(value.cell, into);
      FfiConverterString.write(value.suggestedLabel, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeHeatmapCell.allocationSize(value.cell) +
        FfiConverterString.allocationSize(value.suggestedLabel)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A user-created custom section definition.
 */
export type CustomSection = {
  /**
   * Unique identifier (e.g., "custom_1234567890_abc123")
   */
  id: string;
  /**
   * User-defined name
   */
  name: string;
  /**
   * GPS polyline defining the section path
   */
  polyline: Array<GpsPoint>;
  /**
   * Activity this section was created from
   */
  sourceActivityId: string;
  /**
   * Start index in the source activity's GPS track
   */
  startIndex: /*u32*/ number;
  /**
   * End index in the source activity's GPS track
   */
  endIndex: /*u32*/ number;
  /**
   * Sport type (e.g., "Ride", "Run")
   */
  sportType: string;
  /**
   * Distance in meters
   */
  distanceMeters: /*f64*/ number;
  /**
   * ISO 8601 timestamp when section was created
   */
  createdAt: string;
};

/**
 * Generated factory for {@link CustomSection} record objects.
 */
export const CustomSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CustomSection, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CustomSection}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CustomSection}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CustomSection>,
  });
})();

const FfiConverterTypeCustomSection = (() => {
  type TypeName = CustomSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        polyline: FfiConverterArrayTypeGpsPoint.read(from),
        sourceActivityId: FfiConverterString.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
        sportType: FfiConverterString.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        createdAt: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.name, into);
      FfiConverterArrayTypeGpsPoint.write(value.polyline, into);
      FfiConverterString.write(value.sourceActivityId, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterString.write(value.createdAt, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterArrayTypeGpsPoint.allocationSize(value.polyline) +
        FfiConverterString.allocationSize(value.sourceActivityId) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterString.allocationSize(value.createdAt)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A match between a custom section and an activity.
 */
export type CustomSectionMatch = {
  /**
   * Activity ID that matched the section
   */
  activityId: string;
  /**
   * Start index in the activity's GPS track
   */
  startIndex: /*u32*/ number;
  /**
   * End index in the activity's GPS track
   */
  endIndex: /*u32*/ number;
  /**
   * Direction: "same" or "reverse"
   */
  direction: string;
  /**
   * Distance of the matched portion in meters
   */
  distanceMeters: /*f64*/ number;
};

/**
 * Generated factory for {@link CustomSectionMatch} record objects.
 */
export const CustomSectionMatch = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CustomSectionMatch, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CustomSectionMatch}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CustomSectionMatch}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CustomSectionMatch>,
  });
})();

const FfiConverterTypeCustomSectionMatch = (() => {
  type TypeName = CustomSectionMatch;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
        direction: FfiConverterString.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterFloat64.allocationSize(value.distanceMeters)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration for custom section matching.
 */
export type CustomSectionMatchConfig = {
  /**
   * Maximum distance in meters between section and activity points (default: 50m)
   */
  proximityThreshold: /*f64*/ number;
  /**
   * Minimum percentage of section that must be covered (default: 0.8 = 80%)
   */
  minCoverage: /*f64*/ number;
};

/**
 * Generated factory for {@link CustomSectionMatchConfig} record objects.
 */
export const CustomSectionMatchConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CustomSectionMatchConfig,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CustomSectionMatchConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CustomSectionMatchConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<CustomSectionMatchConfig>,
  });
})();

const FfiConverterTypeCustomSectionMatchConfig = (() => {
  type TypeName = CustomSectionMatchConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        proximityThreshold: FfiConverterFloat64.read(from),
        minCoverage: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.proximityThreshold, into);
      FfiConverterFloat64.write(value.minCoverage, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.proximityThreshold) +
        FfiConverterFloat64.allocationSize(value.minCoverage)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Statistics from section detection
 */
export type DetectionStats = {
  /**
   * Total activities processed
   */
  activitiesProcessed: /*u32*/ number;
  /**
   * Total overlaps found across all scales
   */
  overlapsFound: /*u32*/ number;
  /**
   * Sections per scale
   */
  sectionsByScale: Map<string, /*u32*/ number>;
  /**
   * Potentials per scale
   */
  potentialsByScale: Map<string, /*u32*/ number>;
};

/**
 * Generated factory for {@link DetectionStats} record objects.
 */
export const DetectionStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<DetectionStats, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DetectionStats}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DetectionStats}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<DetectionStats>,
  });
})();

const FfiConverterTypeDetectionStats = (() => {
  type TypeName = DetectionStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activitiesProcessed: FfiConverterUInt32.read(from),
        overlapsFound: FfiConverterUInt32.read(from),
        sectionsByScale: FfiConverterMapStringUInt32.read(from),
        potentialsByScale: FfiConverterMapStringUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.activitiesProcessed, into);
      FfiConverterUInt32.write(value.overlapsFound, into);
      FfiConverterMapStringUInt32.write(value.sectionsByScale, into);
      FfiConverterMapStringUInt32.write(value.potentialsByScale, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.activitiesProcessed) +
        FfiConverterUInt32.allocationSize(value.overlapsFound) +
        FfiConverterMapStringUInt32.allocationSize(value.sectionsByScale) +
        FfiConverterMapStringUInt32.allocationSize(value.potentialsByScale)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of fetching activity map data from intervals.icu
 */
export type FfiActivityMapResult = {
  activityId: string;
  /**
   * Bounds as [ne_lat, ne_lng, sw_lat, sw_lng] or empty if no bounds
   */
  bounds: Array</*f64*/ number>;
  /**
   * GPS coordinates as flat array [lat1, lng1, lat2, lng2, ...]
   */
  latlngs: Array</*f64*/ number>;
  success: boolean;
  error: string | undefined;
};

/**
 * Generated factory for {@link FfiActivityMapResult} record objects.
 */
export const FfiActivityMapResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiActivityMapResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiActivityMapResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiActivityMapResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiActivityMapResult>,
  });
})();

const FfiConverterTypeFfiActivityMapResult = (() => {
  type TypeName = FfiActivityMapResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        bounds: FfiConverterArrayFloat64.read(from),
        latlngs: FfiConverterArrayFloat64.read(from),
        success: FfiConverterBool.read(from),
        error: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterArrayFloat64.write(value.bounds, into);
      FfiConverterArrayFloat64.write(value.latlngs, into);
      FfiConverterBool.write(value.success, into);
      FfiConverterOptionalString.write(value.error, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterArrayFloat64.allocationSize(value.bounds) +
        FfiConverterArrayFloat64.allocationSize(value.latlngs) +
        FfiConverterBool.allocationSize(value.success) +
        FfiConverterOptionalString.allocationSize(value.error)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Input for flat buffer processing (zero-copy from JS TypedArray)
 */
export type FlatGpsTrack = {
  activityId: string;
  /**
   * Flat array of coordinates: [lat1, lng1, lat2, lng2, ...]
   */
  coords: Array</*f64*/ number>;
};

/**
 * Generated factory for {@link FlatGpsTrack} record objects.
 */
export const FlatGpsTrack = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FlatGpsTrack, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FlatGpsTrack}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FlatGpsTrack}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FlatGpsTrack>,
  });
})();

const FfiConverterTypeFlatGpsTrack = (() => {
  type TypeName = FlatGpsTrack;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        coords: FfiConverterArrayFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterArrayFloat64.write(value.coords, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterArrayFloat64.allocationSize(value.coords)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A frequently-traveled section with adaptive consensus representation
 */
export type FrequentSection = {
  /**
   * Unique section ID
   */
  id: string;
  /**
   * Custom name (user-defined, None if not set)
   */
  name: string | undefined;
  /**
   * Sport type ("Run", "Ride", etc.)
   */
  sportType: string;
  /**
   * The consensus polyline - refined from all overlapping tracks
   * Initially the medoid, evolves via weighted averaging as more tracks are added
   */
  polyline: Array<GpsPoint>;
  /**
   * Which activity provided the initial representative polyline (medoid)
   */
  representativeActivityId: string;
  /**
   * All activity IDs that traverse this section
   */
  activityIds: Array<string>;
  /**
   * Each activity's portion (start/end indices, distance, direction)
   */
  activityPortions: Array<SectionPortion>;
  /**
   * Route group IDs that include this section
   */
  routeIds: Array<string>;
  /**
   * Number of times traversed
   */
  visitCount: /*u32*/ number;
  /**
   * Section length in meters
   */
  distanceMeters: /*f64*/ number;
  /**
   * Pre-computed GPS traces for each activity's overlapping portion
   * Key is activity ID, value is the GPS points within proximity of section
   */
  activityTraces: Map<string, Array<GpsPoint>>;
  /**
   * Confidence score (0.0-1.0) based on observation density
   * Higher confidence = more tracks observed, tighter consensus
   */
  confidence: /*f64*/ number;
  /**
   * Number of observations (tracks) used to compute consensus
   */
  observationCount: /*u32*/ number;
  /**
   * Average spread (meters) of track observations from consensus line
   * Lower spread = more consistent track alignment
   */
  averageSpread: /*f64*/ number;
  /**
   * Per-point observation density (how many activities pass through each point)
   * Used for detecting high-traffic portions that should become separate sections
   */
  pointDensity: Array</*u32*/ number>;
  /**
   * Scale at which this section was detected: "short", "medium", "long", or "legacy"
   */
  scale: string | undefined;
  /**
   * Section version - incremented each time the section is updated
   */
  version: /*u32*/ number;
  /**
   * Whether this section was user-defined (prevents automatic updates)
   */
  isUserDefined: boolean;
  /**
   * ISO timestamp when section was created
   */
  createdAt: string | undefined;
  /**
   * ISO timestamp when section was last updated
   */
  updatedAt: string | undefined;
  /**
   * Stability score (0.0-1.0) - how stable the consensus has become
   * High stability = consensus is well-established, unlikely to change significantly
   */
  stability: /*f64*/ number;
};

/**
 * Generated factory for {@link FrequentSection} record objects.
 */
export const FrequentSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FrequentSection, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FrequentSection}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FrequentSection}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FrequentSection>,
  });
})();

const FfiConverterTypeFrequentSection = (() => {
  type TypeName = FrequentSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        sportType: FfiConverterString.read(from),
        polyline: FfiConverterArrayTypeGpsPoint.read(from),
        representativeActivityId: FfiConverterString.read(from),
        activityIds: FfiConverterArrayString.read(from),
        activityPortions: FfiConverterArrayTypeSectionPortion.read(from),
        routeIds: FfiConverterArrayString.read(from),
        visitCount: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        activityTraces: FfiConverterMapStringArrayTypeGpsPoint.read(from),
        confidence: FfiConverterFloat64.read(from),
        observationCount: FfiConverterUInt32.read(from),
        averageSpread: FfiConverterFloat64.read(from),
        pointDensity: FfiConverterArrayUInt32.read(from),
        scale: FfiConverterOptionalString.read(from),
        version: FfiConverterUInt32.read(from),
        isUserDefined: FfiConverterBool.read(from),
        createdAt: FfiConverterOptionalString.read(from),
        updatedAt: FfiConverterOptionalString.read(from),
        stability: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterArrayTypeGpsPoint.write(value.polyline, into);
      FfiConverterString.write(value.representativeActivityId, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterArrayTypeSectionPortion.write(value.activityPortions, into);
      FfiConverterArrayString.write(value.routeIds, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterMapStringArrayTypeGpsPoint.write(value.activityTraces, into);
      FfiConverterFloat64.write(value.confidence, into);
      FfiConverterUInt32.write(value.observationCount, into);
      FfiConverterFloat64.write(value.averageSpread, into);
      FfiConverterArrayUInt32.write(value.pointDensity, into);
      FfiConverterOptionalString.write(value.scale, into);
      FfiConverterUInt32.write(value.version, into);
      FfiConverterBool.write(value.isUserDefined, into);
      FfiConverterOptionalString.write(value.createdAt, into);
      FfiConverterOptionalString.write(value.updatedAt, into);
      FfiConverterFloat64.write(value.stability, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterArrayTypeGpsPoint.allocationSize(value.polyline) +
        FfiConverterString.allocationSize(value.representativeActivityId) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterArrayTypeSectionPortion.allocationSize(
          value.activityPortions,
        ) +
        FfiConverterArrayString.allocationSize(value.routeIds) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterMapStringArrayTypeGpsPoint.allocationSize(
          value.activityTraces,
        ) +
        FfiConverterFloat64.allocationSize(value.confidence) +
        FfiConverterUInt32.allocationSize(value.observationCount) +
        FfiConverterFloat64.allocationSize(value.averageSpread) +
        FfiConverterArrayUInt32.allocationSize(value.pointDensity) +
        FfiConverterOptionalString.allocationSize(value.scale) +
        FfiConverterUInt32.allocationSize(value.version) +
        FfiConverterBool.allocationSize(value.isUserDefined) +
        FfiConverterOptionalString.allocationSize(value.createdAt) +
        FfiConverterOptionalString.allocationSize(value.updatedAt) +
        FfiConverterFloat64.allocationSize(value.stability)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A GPS coordinate with latitude and longitude.
 *
 * # Example
 * ```
 * use tracematch::GpsPoint;
 * let point = GpsPoint::new(51.5074, -0.1278); // London
 * ```
 */
export type GpsPoint = {
  latitude: /*f64*/ number;
  longitude: /*f64*/ number;
  /**
   * Elevation in meters (optional for backward compatibility)
   */
  elevation: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link GpsPoint} record objects.
 */
export const GpsPoint = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GpsPoint, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GpsPoint}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GpsPoint}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GpsPoint>,
  });
})();

const FfiConverterTypeGpsPoint = (() => {
  type TypeName = GpsPoint;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        latitude: FfiConverterFloat64.read(from),
        longitude: FfiConverterFloat64.read(from),
        elevation: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.latitude, into);
      FfiConverterFloat64.write(value.longitude, into);
      FfiConverterOptionalFloat64.write(value.elevation, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.latitude) +
        FfiConverterFloat64.allocationSize(value.longitude) +
        FfiConverterOptionalFloat64.allocationSize(value.elevation)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Bounding box for heatmap computation
 */
export type HeatmapBounds = {
  minLat: /*f64*/ number;
  maxLat: /*f64*/ number;
  minLng: /*f64*/ number;
  maxLng: /*f64*/ number;
};

/**
 * Generated factory for {@link HeatmapBounds} record objects.
 */
export const HeatmapBounds = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HeatmapBounds, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HeatmapBounds}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HeatmapBounds}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HeatmapBounds>,
  });
})();

const FfiConverterTypeHeatmapBounds = (() => {
  type TypeName = HeatmapBounds;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        minLat: FfiConverterFloat64.read(from),
        maxLat: FfiConverterFloat64.read(from),
        minLng: FfiConverterFloat64.read(from),
        maxLng: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.minLat, into);
      FfiConverterFloat64.write(value.maxLat, into);
      FfiConverterFloat64.write(value.minLng, into);
      FfiConverterFloat64.write(value.maxLng, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.minLat) +
        FfiConverterFloat64.allocationSize(value.maxLat) +
        FfiConverterFloat64.allocationSize(value.minLng) +
        FfiConverterFloat64.allocationSize(value.maxLng)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A single cell in the heatmap grid
 */
export type HeatmapCell = {
  /**
   * Grid row index
   */
  row: /*i32*/ number;
  /**
   * Grid column index
   */
  col: /*i32*/ number;
  /**
   * Cell center for rendering
   */
  centerLat: /*f64*/ number;
  centerLng: /*f64*/ number;
  /**
   * Normalized density (0.0-1.0) for color mapping
   */
  density: /*f32*/ number;
  /**
   * Total visit count (sum of all point traversals)
   */
  visitCount: /*u32*/ number;
  /**
   * Routes passing through this cell
   */
  routeRefs: Array<RouteRef>;
  /**
   * Number of unique routes
   */
  uniqueRouteCount: /*u32*/ number;
  /**
   * All activity IDs that pass through
   */
  activityIds: Array<string>;
  /**
   * Earliest visit (Unix timestamp)
   */
  firstVisit: /*i64*/ bigint | undefined;
  /**
   * Most recent visit (Unix timestamp)
   */
  lastVisit: /*i64*/ bigint | undefined;
  /**
   * True if 2+ routes share this cell (intersection/common path)
   */
  isCommonPath: boolean;
};

/**
 * Generated factory for {@link HeatmapCell} record objects.
 */
export const HeatmapCell = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HeatmapCell, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HeatmapCell}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HeatmapCell}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HeatmapCell>,
  });
})();

const FfiConverterTypeHeatmapCell = (() => {
  type TypeName = HeatmapCell;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        row: FfiConverterInt32.read(from),
        col: FfiConverterInt32.read(from),
        centerLat: FfiConverterFloat64.read(from),
        centerLng: FfiConverterFloat64.read(from),
        density: FfiConverterFloat32.read(from),
        visitCount: FfiConverterUInt32.read(from),
        routeRefs: FfiConverterArrayTypeRouteRef.read(from),
        uniqueRouteCount: FfiConverterUInt32.read(from),
        activityIds: FfiConverterArrayString.read(from),
        firstVisit: FfiConverterOptionalInt64.read(from),
        lastVisit: FfiConverterOptionalInt64.read(from),
        isCommonPath: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt32.write(value.row, into);
      FfiConverterInt32.write(value.col, into);
      FfiConverterFloat64.write(value.centerLat, into);
      FfiConverterFloat64.write(value.centerLng, into);
      FfiConverterFloat32.write(value.density, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterArrayTypeRouteRef.write(value.routeRefs, into);
      FfiConverterUInt32.write(value.uniqueRouteCount, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterOptionalInt64.write(value.firstVisit, into);
      FfiConverterOptionalInt64.write(value.lastVisit, into);
      FfiConverterBool.write(value.isCommonPath, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt32.allocationSize(value.row) +
        FfiConverterInt32.allocationSize(value.col) +
        FfiConverterFloat64.allocationSize(value.centerLat) +
        FfiConverterFloat64.allocationSize(value.centerLng) +
        FfiConverterFloat32.allocationSize(value.density) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterArrayTypeRouteRef.allocationSize(value.routeRefs) +
        FfiConverterUInt32.allocationSize(value.uniqueRouteCount) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterOptionalInt64.allocationSize(value.firstVisit) +
        FfiConverterOptionalInt64.allocationSize(value.lastVisit) +
        FfiConverterBool.allocationSize(value.isCommonPath)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration for heatmap generation
 */
export type HeatmapConfig = {
  /**
   * Grid cell size in meters (default: 100m)
   */
  cellSizeMeters: /*f64*/ number;
  /**
   * Optional bounds to limit computation
   */
  bounds: HeatmapBounds | undefined;
};

/**
 * Generated factory for {@link HeatmapConfig} record objects.
 */
export const HeatmapConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HeatmapConfig, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HeatmapConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HeatmapConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HeatmapConfig>,
  });
})();

const FfiConverterTypeHeatmapConfig = (() => {
  type TypeName = HeatmapConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        cellSizeMeters: FfiConverterFloat64.read(from),
        bounds: FfiConverterOptionalTypeHeatmapBounds.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.cellSizeMeters, into);
      FfiConverterOptionalTypeHeatmapBounds.write(value.bounds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.cellSizeMeters) +
        FfiConverterOptionalTypeHeatmapBounds.allocationSize(value.bounds)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Complete heatmap result
 */
export type HeatmapResult = {
  /**
   * Non-empty cells only (sparse representation)
   */
  cells: Array<HeatmapCell>;
  /**
   * Computed bounds (from data or config)
   */
  bounds: HeatmapBounds;
  /**
   * Cell size used
   */
  cellSizeMeters: /*f64*/ number;
  /**
   * Grid dimensions
   */
  gridRows: /*u32*/ number;
  gridCols: /*u32*/ number;
  /**
   * Maximum density for normalization
   */
  maxDensity: /*f32*/ number;
  /**
   * Summary stats
   */
  totalRoutes: /*u32*/ number;
  totalActivities: /*u32*/ number;
};

/**
 * Generated factory for {@link HeatmapResult} record objects.
 */
export const HeatmapResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HeatmapResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HeatmapResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HeatmapResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HeatmapResult>,
  });
})();

const FfiConverterTypeHeatmapResult = (() => {
  type TypeName = HeatmapResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        cells: FfiConverterArrayTypeHeatmapCell.read(from),
        bounds: FfiConverterTypeHeatmapBounds.read(from),
        cellSizeMeters: FfiConverterFloat64.read(from),
        gridRows: FfiConverterUInt32.read(from),
        gridCols: FfiConverterUInt32.read(from),
        maxDensity: FfiConverterFloat32.read(from),
        totalRoutes: FfiConverterUInt32.read(from),
        totalActivities: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeHeatmapCell.write(value.cells, into);
      FfiConverterTypeHeatmapBounds.write(value.bounds, into);
      FfiConverterFloat64.write(value.cellSizeMeters, into);
      FfiConverterUInt32.write(value.gridRows, into);
      FfiConverterUInt32.write(value.gridCols, into);
      FfiConverterFloat32.write(value.maxDensity, into);
      FfiConverterUInt32.write(value.totalRoutes, into);
      FfiConverterUInt32.write(value.totalActivities, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeHeatmapCell.allocationSize(value.cells) +
        FfiConverterTypeHeatmapBounds.allocationSize(value.bounds) +
        FfiConverterFloat64.allocationSize(value.cellSizeMeters) +
        FfiConverterUInt32.allocationSize(value.gridRows) +
        FfiConverterUInt32.allocationSize(value.gridCols) +
        FfiConverterFloat32.allocationSize(value.maxDensity) +
        FfiConverterUInt32.allocationSize(value.totalRoutes) +
        FfiConverterUInt32.allocationSize(value.totalActivities)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration for route matching algorithms.
 */
export type MatchConfig = {
  /**
   * AMD threshold for perfect match (100%). Routes with AMD below this are considered identical.
   * Default: 30.0 meters (accounts for GPS variance of 5-10m)
   */
  perfectThreshold: /*f64*/ number;
  /**
   * AMD threshold for no match (0%). Routes with AMD above this are considered different.
   * Default: 250.0 meters
   */
  zeroThreshold: /*f64*/ number;
  /**
   * Minimum match percentage to consider routes similar.
   * Default: 65.0% (lowered from 80% to account for GPS variance)
   */
  minMatchPercentage: /*f64*/ number;
  /**
   * Minimum route distance to be considered for grouping.
   * Default: 500.0 meters
   */
  minRouteDistance: /*f64*/ number;
  /**
   * Maximum distance difference ratio for grouping (within 20%).
   * Default: 0.20
   */
  maxDistanceDiffRatio: /*f64*/ number;
  /**
   * Endpoint threshold for matching start/end points.
   * Default: 200.0 meters
   */
  endpointThreshold: /*f64*/ number;
  /**
   * Fixed number of points for resampling (legacy mode).
   * If resample_spacing_meters > 0, this is ignored in favor of distance-proportional resampling.
   * Default: 50
   */
  resampleCount: /*u32*/ number;
  /**
   * Target spacing between resampled points in meters.
   * When > 0, enables distance-proportional resampling for consistent granularity.
   * Set to 0 to use fixed resample_count instead.
   * Default: 50.0 meters
   */
  resampleSpacingMeters: /*f64*/ number;
  /**
   * Minimum number of resampled points (only used with distance-proportional resampling).
   * Default: 20
   */
  minResamplePoints: /*u32*/ number;
  /**
   * Maximum number of resampled points (only used with distance-proportional resampling).
   * Caps comparison complexity for very long routes.
   * Default: 200
   */
  maxResamplePoints: /*u32*/ number;
  /**
   * Tolerance for Douglas-Peucker simplification (in degrees).
   * Smaller values preserve more detail. Default: 0.0001 (~11 meters)
   */
  simplificationTolerance: /*f64*/ number;
  /**
   * Maximum points after simplification.
   * Fewer points = faster comparison. Default: 100
   */
  maxSimplifiedPoints: /*u32*/ number;
};

/**
 * Generated factory for {@link MatchConfig} record objects.
 */
export const MatchConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MatchConfig, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MatchConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MatchConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MatchConfig>,
  });
})();

const FfiConverterTypeMatchConfig = (() => {
  type TypeName = MatchConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        perfectThreshold: FfiConverterFloat64.read(from),
        zeroThreshold: FfiConverterFloat64.read(from),
        minMatchPercentage: FfiConverterFloat64.read(from),
        minRouteDistance: FfiConverterFloat64.read(from),
        maxDistanceDiffRatio: FfiConverterFloat64.read(from),
        endpointThreshold: FfiConverterFloat64.read(from),
        resampleCount: FfiConverterUInt32.read(from),
        resampleSpacingMeters: FfiConverterFloat64.read(from),
        minResamplePoints: FfiConverterUInt32.read(from),
        maxResamplePoints: FfiConverterUInt32.read(from),
        simplificationTolerance: FfiConverterFloat64.read(from),
        maxSimplifiedPoints: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.perfectThreshold, into);
      FfiConverterFloat64.write(value.zeroThreshold, into);
      FfiConverterFloat64.write(value.minMatchPercentage, into);
      FfiConverterFloat64.write(value.minRouteDistance, into);
      FfiConverterFloat64.write(value.maxDistanceDiffRatio, into);
      FfiConverterFloat64.write(value.endpointThreshold, into);
      FfiConverterUInt32.write(value.resampleCount, into);
      FfiConverterFloat64.write(value.resampleSpacingMeters, into);
      FfiConverterUInt32.write(value.minResamplePoints, into);
      FfiConverterUInt32.write(value.maxResamplePoints, into);
      FfiConverterFloat64.write(value.simplificationTolerance, into);
      FfiConverterUInt32.write(value.maxSimplifiedPoints, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.perfectThreshold) +
        FfiConverterFloat64.allocationSize(value.zeroThreshold) +
        FfiConverterFloat64.allocationSize(value.minMatchPercentage) +
        FfiConverterFloat64.allocationSize(value.minRouteDistance) +
        FfiConverterFloat64.allocationSize(value.maxDistanceDiffRatio) +
        FfiConverterFloat64.allocationSize(value.endpointThreshold) +
        FfiConverterUInt32.allocationSize(value.resampleCount) +
        FfiConverterFloat64.allocationSize(value.resampleSpacingMeters) +
        FfiConverterUInt32.allocationSize(value.minResamplePoints) +
        FfiConverterUInt32.allocationSize(value.maxResamplePoints) +
        FfiConverterFloat64.allocationSize(value.simplificationTolerance) +
        FfiConverterUInt32.allocationSize(value.maxSimplifiedPoints)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of comparing two routes.
 */
export type MatchResult = {
  /**
   * ID of the first route
   */
  activityId1: string;
  /**
   * ID of the second route
   */
  activityId2: string;
  /**
   * Match percentage (0-100, higher = better match)
   */
  matchPercentage: /*f64*/ number;
  /**
   * Direction: "same", "reverse", or "partial"
   */
  direction: string;
  /**
   * Average Minimum Distance in meters (lower = better match)
   */
  amd: /*f64*/ number;
};

/**
 * Generated factory for {@link MatchResult} record objects.
 */
export const MatchResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MatchResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MatchResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MatchResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MatchResult>,
  });
})();

const FfiConverterTypeMatchResult = (() => {
  type TypeName = MatchResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId1: FfiConverterString.read(from),
        activityId2: FfiConverterString.read(from),
        matchPercentage: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
        amd: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId1, into);
      FfiConverterString.write(value.activityId2, into);
      FfiConverterFloat64.write(value.matchPercentage, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterFloat64.write(value.amd, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId1) +
        FfiConverterString.allocationSize(value.activityId2) +
        FfiConverterFloat64.allocationSize(value.matchPercentage) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterFloat64.allocationSize(value.amd)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of multi-scale section detection
 */
export type MultiScaleSectionResult = {
  /**
   * Confirmed sections (min_activities met)
   */
  sections: Array<FrequentSection>;
  /**
   * Potential sections (1-2 activities, suggestions for user)
   */
  potentials: Array<PotentialSection>;
  /**
   * Statistics about detection
   */
  stats: DetectionStats;
};

/**
 * Generated factory for {@link MultiScaleSectionResult} record objects.
 */
export const MultiScaleSectionResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      MultiScaleSectionResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MultiScaleSectionResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MultiScaleSectionResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<MultiScaleSectionResult>,
  });
})();

const FfiConverterTypeMultiScaleSectionResult = (() => {
  type TypeName = MultiScaleSectionResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sections: FfiConverterArrayTypeFrequentSection.read(from),
        potentials: FfiConverterArrayTypePotentialSection.read(from),
        stats: FfiConverterTypeDetectionStats.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFrequentSection.write(value.sections, into);
      FfiConverterArrayTypePotentialSection.write(value.potentials, into);
      FfiConverterTypeDetectionStats.write(value.stats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeFrequentSection.allocationSize(value.sections) +
        FfiConverterArrayTypePotentialSection.allocationSize(value.potentials) +
        FfiConverterTypeDetectionStats.allocationSize(value.stats)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Statistics for the persistent engine.
 */
export type PersistentEngineStats = {
  activityCount: /*u32*/ number;
  signatureCacheSize: /*u32*/ number;
  consensusCacheSize: /*u32*/ number;
  groupCount: /*u32*/ number;
  sectionCount: /*u32*/ number;
  groupsDirty: boolean;
  sectionsDirty: boolean;
  gpsTrackCount: /*u32*/ number;
};

/**
 * Generated factory for {@link PersistentEngineStats} record objects.
 */
export const PersistentEngineStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PersistentEngineStats,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PersistentEngineStats}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PersistentEngineStats}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PersistentEngineStats>,
  });
})();

const FfiConverterTypePersistentEngineStats = (() => {
  type TypeName = PersistentEngineStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityCount: FfiConverterUInt32.read(from),
        signatureCacheSize: FfiConverterUInt32.read(from),
        consensusCacheSize: FfiConverterUInt32.read(from),
        groupCount: FfiConverterUInt32.read(from),
        sectionCount: FfiConverterUInt32.read(from),
        groupsDirty: FfiConverterBool.read(from),
        sectionsDirty: FfiConverterBool.read(from),
        gpsTrackCount: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterUInt32.write(value.signatureCacheSize, into);
      FfiConverterUInt32.write(value.consensusCacheSize, into);
      FfiConverterUInt32.write(value.groupCount, into);
      FfiConverterUInt32.write(value.sectionCount, into);
      FfiConverterBool.write(value.groupsDirty, into);
      FfiConverterBool.write(value.sectionsDirty, into);
      FfiConverterUInt32.write(value.gpsTrackCount, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterUInt32.allocationSize(value.signatureCacheSize) +
        FfiConverterUInt32.allocationSize(value.consensusCacheSize) +
        FfiConverterUInt32.allocationSize(value.groupCount) +
        FfiConverterUInt32.allocationSize(value.sectionCount) +
        FfiConverterBool.allocationSize(value.groupsDirty) +
        FfiConverterBool.allocationSize(value.sectionsDirty) +
        FfiConverterUInt32.allocationSize(value.gpsTrackCount)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A potential section detected from 1-2 activities.
 * These are suggestions that users can promote to full sections.
 */
export type PotentialSection = {
  /**
   * Unique section ID
   */
  id: string;
  /**
   * Sport type ("Run", "Ride", etc.)
   */
  sportType: string;
  /**
   * The polyline from the representative activity
   */
  polyline: Array<GpsPoint>;
  /**
   * Activity IDs that traverse this potential section (1-2)
   */
  activityIds: Array<string>;
  /**
   * Number of times traversed (1-2)
   */
  visitCount: /*u32*/ number;
  /**
   * Section length in meters
   */
  distanceMeters: /*f64*/ number;
  /**
   * Confidence score (0.0-1.0), lower than FrequentSection
   */
  confidence: /*f64*/ number;
  /**
   * Scale at which this was detected
   */
  scale: string;
};

/**
 * Generated factory for {@link PotentialSection} record objects.
 */
export const PotentialSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PotentialSection, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PotentialSection}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PotentialSection}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PotentialSection>,
  });
})();

const FfiConverterTypePotentialSection = (() => {
  type TypeName = PotentialSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
        polyline: FfiConverterArrayTypeGpsPoint.read(from),
        activityIds: FfiConverterArrayString.read(from),
        visitCount: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        confidence: FfiConverterFloat64.read(from),
        scale: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterArrayTypeGpsPoint.write(value.polyline, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterFloat64.write(value.confidence, into);
      FfiConverterString.write(value.scale, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterArrayTypeGpsPoint.allocationSize(value.polyline) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterFloat64.allocationSize(value.confidence) +
        FfiConverterString.allocationSize(value.scale)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A group of similar routes.
 */
export type RouteGroup = {
  /**
   * Unique identifier for this group (typically the first activity ID)
   */
  groupId: string;
  /**
   * ID of the representative activity (the medoid)
   */
  representativeId: string;
  /**
   * All activity IDs that belong to this group
   */
  activityIds: Array<string>;
  /**
   * Sport type for this group (e.g., "Ride", "Run")
   */
  sportType: string;
  /**
   * Bounding box for all activities in the group
   */
  bounds: Bounds | undefined;
  /**
   * User-defined custom name for this route (None = use auto-generated name)
   */
  customName: string | undefined;
  /**
   * Best moving time in seconds (fastest completion)
   */
  bestTime: /*f64*/ number | undefined;
  /**
   * Average moving time in seconds
   */
  avgTime: /*f64*/ number | undefined;
  /**
   * Best pace/speed in m/s (from fastest activity)
   */
  bestPace: /*f64*/ number | undefined;
  /**
   * Activity ID with the best performance
   */
  bestActivityId: string | undefined;
};

/**
 * Generated factory for {@link RouteGroup} record objects.
 */
export const RouteGroup = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RouteGroup, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RouteGroup}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RouteGroup}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RouteGroup>,
  });
})();

const FfiConverterTypeRouteGroup = (() => {
  type TypeName = RouteGroup;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        groupId: FfiConverterString.read(from),
        representativeId: FfiConverterString.read(from),
        activityIds: FfiConverterArrayString.read(from),
        sportType: FfiConverterString.read(from),
        bounds: FfiConverterOptionalTypeBounds.read(from),
        customName: FfiConverterOptionalString.read(from),
        bestTime: FfiConverterOptionalFloat64.read(from),
        avgTime: FfiConverterOptionalFloat64.read(from),
        bestPace: FfiConverterOptionalFloat64.read(from),
        bestActivityId: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.groupId, into);
      FfiConverterString.write(value.representativeId, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterOptionalTypeBounds.write(value.bounds, into);
      FfiConverterOptionalString.write(value.customName, into);
      FfiConverterOptionalFloat64.write(value.bestTime, into);
      FfiConverterOptionalFloat64.write(value.avgTime, into);
      FfiConverterOptionalFloat64.write(value.bestPace, into);
      FfiConverterOptionalString.write(value.bestActivityId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.groupId) +
        FfiConverterString.allocationSize(value.representativeId) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterOptionalTypeBounds.allocationSize(value.bounds) +
        FfiConverterOptionalString.allocationSize(value.customName) +
        FfiConverterOptionalFloat64.allocationSize(value.bestTime) +
        FfiConverterOptionalFloat64.allocationSize(value.avgTime) +
        FfiConverterOptionalFloat64.allocationSize(value.bestPace) +
        FfiConverterOptionalString.allocationSize(value.bestActivityId)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A single performance point for route comparison.
 */
export type RoutePerformance = {
  activityId: string;
  name: string;
  /**
   * Unix timestamp
   */
  date: /*i64*/ bigint;
  /**
   * Speed in m/s (distance / moving_time)
   */
  speed: /*f64*/ number;
  /**
   * Elapsed time in seconds
   */
  duration: /*u32*/ number;
  /**
   * Moving time in seconds
   */
  movingTime: /*u32*/ number;
  /**
   * Distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Elevation gain in meters
   */
  elevationGain: /*f64*/ number;
  /**
   * Average heart rate (optional)
   */
  avgHr: /*u16*/ number | undefined;
  /**
   * Average power in watts (optional)
   */
  avgPower: /*u16*/ number | undefined;
  /**
   * Is this the current activity being viewed
   */
  isCurrent: boolean;
  /**
   * Match direction: "same", "reverse", or "partial"
   */
  direction: string;
  /**
   * Match percentage (0-100)
   */
  matchPercentage: /*f64*/ number;
};

/**
 * Generated factory for {@link RoutePerformance} record objects.
 */
export const RoutePerformance = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoutePerformance, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoutePerformance}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoutePerformance}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoutePerformance>,
  });
})();

const FfiConverterTypeRoutePerformance = (() => {
  type TypeName = RoutePerformance;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        date: FfiConverterInt64.read(from),
        speed: FfiConverterFloat64.read(from),
        duration: FfiConverterUInt32.read(from),
        movingTime: FfiConverterUInt32.read(from),
        distance: FfiConverterFloat64.read(from),
        elevationGain: FfiConverterFloat64.read(from),
        avgHr: FfiConverterOptionalUInt16.read(from),
        avgPower: FfiConverterOptionalUInt16.read(from),
        isCurrent: FfiConverterBool.read(from),
        direction: FfiConverterString.read(from),
        matchPercentage: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.name, into);
      FfiConverterInt64.write(value.date, into);
      FfiConverterFloat64.write(value.speed, into);
      FfiConverterUInt32.write(value.duration, into);
      FfiConverterUInt32.write(value.movingTime, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterFloat64.write(value.elevationGain, into);
      FfiConverterOptionalUInt16.write(value.avgHr, into);
      FfiConverterOptionalUInt16.write(value.avgPower, into);
      FfiConverterBool.write(value.isCurrent, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterFloat64.write(value.matchPercentage, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterInt64.allocationSize(value.date) +
        FfiConverterFloat64.allocationSize(value.speed) +
        FfiConverterUInt32.allocationSize(value.duration) +
        FfiConverterUInt32.allocationSize(value.movingTime) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterFloat64.allocationSize(value.elevationGain) +
        FfiConverterOptionalUInt16.allocationSize(value.avgHr) +
        FfiConverterOptionalUInt16.allocationSize(value.avgPower) +
        FfiConverterBool.allocationSize(value.isCurrent) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterFloat64.allocationSize(value.matchPercentage)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Complete route performance result.
 */
export type RoutePerformanceResult = {
  /**
   * Performances sorted by date (oldest first)
   */
  performances: Array<RoutePerformance>;
  /**
   * Best performance (fastest speed)
   */
  best: RoutePerformance | undefined;
  /**
   * Current activity's rank (1 = fastest), if current_activity_id was provided
   */
  currentRank: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link RoutePerformanceResult} record objects.
 */
export const RoutePerformanceResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoutePerformanceResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoutePerformanceResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoutePerformanceResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoutePerformanceResult>,
  });
})();

const FfiConverterTypeRoutePerformanceResult = (() => {
  type TypeName = RoutePerformanceResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        performances: FfiConverterArrayTypeRoutePerformance.read(from),
        best: FfiConverterOptionalTypeRoutePerformance.read(from),
        currentRank: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeRoutePerformance.write(value.performances, into);
      FfiConverterOptionalTypeRoutePerformance.write(value.best, into);
      FfiConverterOptionalUInt32.write(value.currentRank, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeRoutePerformance.allocationSize(
          value.performances,
        ) +
        FfiConverterOptionalTypeRoutePerformance.allocationSize(value.best) +
        FfiConverterOptionalUInt32.allocationSize(value.currentRank)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Reference to a route group passing through a cell
 */
export type RouteRef = {
  /**
   * Route group ID
   */
  routeId: string;
  /**
   * How many activities from this route pass through this cell
   */
  activityCount: /*u32*/ number;
  /**
   * User-defined or auto-generated route name
   */
  name: string | undefined;
};

/**
 * Generated factory for {@link RouteRef} record objects.
 */
export const RouteRef = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RouteRef, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RouteRef}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RouteRef}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RouteRef>,
  });
})();

const FfiConverterTypeRouteRef = (() => {
  type TypeName = RouteRef;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        routeId: FfiConverterString.read(from),
        activityCount: FfiConverterUInt32.read(from),
        name: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.routeId, into);
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterOptionalString.write(value.name, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.routeId) +
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterOptionalString.allocationSize(value.name)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A simplified route signature for efficient matching.
 *
 * The signature contains a simplified version of the original GPS track,
 * optimized for comparison using the Fréchet distance algorithm.
 */
export type RouteSignature = {
  /**
   * Unique identifier for the activity/route
   */
  activityId: string;
  /**
   * Simplified GPS points
   */
  points: Array<GpsPoint>;
  /**
   * Total route distance in meters
   */
  totalDistance: /*f64*/ number;
  /**
   * Starting point of the route
   */
  startPoint: GpsPoint;
  /**
   * Ending point of the route
   */
  endPoint: GpsPoint;
  /**
   * Pre-computed bounding box (normalized, ready for use)
   */
  bounds: Bounds;
  /**
   * Pre-computed center point (for map rendering without JS calculation)
   */
  center: GpsPoint;
};

/**
 * Generated factory for {@link RouteSignature} record objects.
 */
export const RouteSignature = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RouteSignature, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RouteSignature}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RouteSignature}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RouteSignature>,
  });
})();

const FfiConverterTypeRouteSignature = (() => {
  type TypeName = RouteSignature;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        points: FfiConverterArrayTypeGpsPoint.read(from),
        totalDistance: FfiConverterFloat64.read(from),
        startPoint: FfiConverterTypeGpsPoint.read(from),
        endPoint: FfiConverterTypeGpsPoint.read(from),
        bounds: FfiConverterTypeBounds.read(from),
        center: FfiConverterTypeGpsPoint.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterArrayTypeGpsPoint.write(value.points, into);
      FfiConverterFloat64.write(value.totalDistance, into);
      FfiConverterTypeGpsPoint.write(value.startPoint, into);
      FfiConverterTypeGpsPoint.write(value.endPoint, into);
      FfiConverterTypeBounds.write(value.bounds, into);
      FfiConverterTypeGpsPoint.write(value.center, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterArrayTypeGpsPoint.allocationSize(value.points) +
        FfiConverterFloat64.allocationSize(value.totalDistance) +
        FfiConverterTypeGpsPoint.allocationSize(value.startPoint) +
        FfiConverterTypeGpsPoint.allocationSize(value.endPoint) +
        FfiConverterTypeBounds.allocationSize(value.bounds) +
        FfiConverterTypeGpsPoint.allocationSize(value.center)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Scale preset for multi-scale section detection
 */
export type ScalePreset = {
  /**
   * Scale name: "short", "medium", "long"
   */
  name: string;
  /**
   * Minimum section length for this scale (meters)
   */
  minLength: /*f64*/ number;
  /**
   * Maximum section length for this scale (meters)
   */
  maxLength: /*f64*/ number;
  /**
   * Minimum activities required at this scale (can be lower for short sections)
   */
  minActivities: /*u32*/ number;
};

/**
 * Generated factory for {@link ScalePreset} record objects.
 */
export const ScalePreset = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ScalePreset, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ScalePreset}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ScalePreset}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ScalePreset>,
  });
})();

const FfiConverterTypeScalePreset = (() => {
  type TypeName = ScalePreset;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        minLength: FfiConverterFloat64.read(from),
        maxLength: FfiConverterFloat64.read(from),
        minActivities: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterFloat64.write(value.minLength, into);
      FfiConverterFloat64.write(value.maxLength, into);
      FfiConverterUInt32.write(value.minActivities, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterFloat64.allocationSize(value.minLength) +
        FfiConverterFloat64.allocationSize(value.maxLength) +
        FfiConverterUInt32.allocationSize(value.minActivities)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration for section detection
 */
export type SectionConfig = {
  /**
   * Maximum distance between tracks to consider overlapping (meters)
   */
  proximityThreshold: /*f64*/ number;
  /**
   * Minimum overlap length to consider a section (meters)
   */
  minSectionLength: /*f64*/ number;
  /**
   * Maximum section length (meters) - prevents sections from becoming full routes
   */
  maxSectionLength: /*f64*/ number;
  /**
   * Minimum number of activities that must share an overlap
   */
  minActivities: /*u32*/ number;
  /**
   * Tolerance for clustering similar overlaps (meters)
   */
  clusterTolerance: /*f64*/ number;
  /**
   * Number of sample points for AMD comparison (not for output!)
   */
  samplePoints: /*u32*/ number;
  /**
   * Detection mode: "discovery" (lower thresholds) or "conservative"
   */
  detectionMode: string;
  /**
   * Include potential sections with only 1-2 activities as suggestions
   */
  includePotentials: boolean;
  /**
   * Scale presets for multi-scale detection (empty = single-scale with min/max_section_length)
   */
  scalePresets: Array<ScalePreset>;
  /**
   * Preserve hierarchical sections (don't deduplicate short sections inside longer ones)
   */
  preserveHierarchy: boolean;
};

/**
 * Generated factory for {@link SectionConfig} record objects.
 */
export const SectionConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SectionConfig, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionConfig}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SectionConfig>,
  });
})();

const FfiConverterTypeSectionConfig = (() => {
  type TypeName = SectionConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        proximityThreshold: FfiConverterFloat64.read(from),
        minSectionLength: FfiConverterFloat64.read(from),
        maxSectionLength: FfiConverterFloat64.read(from),
        minActivities: FfiConverterUInt32.read(from),
        clusterTolerance: FfiConverterFloat64.read(from),
        samplePoints: FfiConverterUInt32.read(from),
        detectionMode: FfiConverterString.read(from),
        includePotentials: FfiConverterBool.read(from),
        scalePresets: FfiConverterArrayTypeScalePreset.read(from),
        preserveHierarchy: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.proximityThreshold, into);
      FfiConverterFloat64.write(value.minSectionLength, into);
      FfiConverterFloat64.write(value.maxSectionLength, into);
      FfiConverterUInt32.write(value.minActivities, into);
      FfiConverterFloat64.write(value.clusterTolerance, into);
      FfiConverterUInt32.write(value.samplePoints, into);
      FfiConverterString.write(value.detectionMode, into);
      FfiConverterBool.write(value.includePotentials, into);
      FfiConverterArrayTypeScalePreset.write(value.scalePresets, into);
      FfiConverterBool.write(value.preserveHierarchy, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.proximityThreshold) +
        FfiConverterFloat64.allocationSize(value.minSectionLength) +
        FfiConverterFloat64.allocationSize(value.maxSectionLength) +
        FfiConverterUInt32.allocationSize(value.minActivities) +
        FfiConverterFloat64.allocationSize(value.clusterTolerance) +
        FfiConverterUInt32.allocationSize(value.samplePoints) +
        FfiConverterString.allocationSize(value.detectionMode) +
        FfiConverterBool.allocationSize(value.includePotentials) +
        FfiConverterArrayTypeScalePreset.allocationSize(value.scalePresets) +
        FfiConverterBool.allocationSize(value.preserveHierarchy)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A single lap of a section.
 */
export type SectionLap = {
  id: string;
  activityId: string;
  /**
   * Lap time in seconds
   */
  time: /*f64*/ number;
  /**
   * Pace in m/s
   */
  pace: /*f64*/ number;
  /**
   * Distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Direction: "forward" or "backward"
   */
  direction: string;
  /**
   * Start index in the activity's GPS track
   */
  startIndex: /*u32*/ number;
  /**
   * End index in the activity's GPS track
   */
  endIndex: /*u32*/ number;
};

/**
 * Generated factory for {@link SectionLap} record objects.
 */
export const SectionLap = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SectionLap, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionLap}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionLap}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SectionLap>,
  });
})();

const FfiConverterTypeSectionLap = (() => {
  type TypeName = SectionLap;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        activityId: FfiConverterString.read(from),
        time: FfiConverterFloat64.read(from),
        pace: FfiConverterFloat64.read(from),
        distance: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.activityId, into);
      FfiConverterFloat64.write(value.time, into);
      FfiConverterFloat64.write(value.pace, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterFloat64.allocationSize(value.time) +
        FfiConverterFloat64.allocationSize(value.pace) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A section match found within a route
 */
export type SectionMatch = {
  /**
   * The section ID that was matched
   */
  sectionId: string;
  /**
   * Start index in the route's GPS points
   */
  startIndex: /*u64*/ bigint;
  /**
   * End index in the route's GPS points (exclusive)
   */
  endIndex: /*u64*/ bigint;
  /**
   * Match quality (0.0 to 1.0)
   */
  matchQuality: /*f64*/ number;
  /**
   * Direction: true if route travels same direction as section, false if reversed
   */
  sameDirection: boolean;
};

/**
 * Generated factory for {@link SectionMatch} record objects.
 */
export const SectionMatch = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SectionMatch, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionMatch}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionMatch}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SectionMatch>,
  });
})();

const FfiConverterTypeSectionMatch = (() => {
  type TypeName = SectionMatch;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sectionId: FfiConverterString.read(from),
        startIndex: FfiConverterUInt64.read(from),
        endIndex: FfiConverterUInt64.read(from),
        matchQuality: FfiConverterFloat64.read(from),
        sameDirection: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.sectionId, into);
      FfiConverterUInt64.write(value.startIndex, into);
      FfiConverterUInt64.write(value.endIndex, into);
      FfiConverterFloat64.write(value.matchQuality, into);
      FfiConverterBool.write(value.sameDirection, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.sectionId) +
        FfiConverterUInt64.allocationSize(value.startIndex) +
        FfiConverterUInt64.allocationSize(value.endIndex) +
        FfiConverterFloat64.allocationSize(value.matchQuality) +
        FfiConverterBool.allocationSize(value.sameDirection)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section performance record for an activity.
 */
export type SectionPerformanceRecord = {
  activityId: string;
  activityName: string;
  /**
   * Unix timestamp
   */
  activityDate: /*i64*/ bigint;
  /**
   * All laps for this activity on this section
   */
  laps: Array<SectionLap>;
  /**
   * Number of times this section was traversed
   */
  lapCount: /*u32*/ number;
  /**
   * Best (fastest) lap time in seconds
   */
  bestTime: /*f64*/ number;
  /**
   * Best pace in m/s
   */
  bestPace: /*f64*/ number;
  /**
   * Average lap time in seconds
   */
  avgTime: /*f64*/ number;
  /**
   * Average pace in m/s
   */
  avgPace: /*f64*/ number;
  /**
   * Primary direction: "forward" or "backward"
   */
  direction: string;
  /**
   * Section distance in meters
   */
  sectionDistance: /*f64*/ number;
};

/**
 * Generated factory for {@link SectionPerformanceRecord} record objects.
 */
export const SectionPerformanceRecord = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SectionPerformanceRecord,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionPerformanceRecord}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionPerformanceRecord}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SectionPerformanceRecord>,
  });
})();

const FfiConverterTypeSectionPerformanceRecord = (() => {
  type TypeName = SectionPerformanceRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        activityName: FfiConverterString.read(from),
        activityDate: FfiConverterInt64.read(from),
        laps: FfiConverterArrayTypeSectionLap.read(from),
        lapCount: FfiConverterUInt32.read(from),
        bestTime: FfiConverterFloat64.read(from),
        bestPace: FfiConverterFloat64.read(from),
        avgTime: FfiConverterFloat64.read(from),
        avgPace: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
        sectionDistance: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.activityName, into);
      FfiConverterInt64.write(value.activityDate, into);
      FfiConverterArrayTypeSectionLap.write(value.laps, into);
      FfiConverterUInt32.write(value.lapCount, into);
      FfiConverterFloat64.write(value.bestTime, into);
      FfiConverterFloat64.write(value.bestPace, into);
      FfiConverterFloat64.write(value.avgTime, into);
      FfiConverterFloat64.write(value.avgPace, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterFloat64.write(value.sectionDistance, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.activityName) +
        FfiConverterInt64.allocationSize(value.activityDate) +
        FfiConverterArrayTypeSectionLap.allocationSize(value.laps) +
        FfiConverterUInt32.allocationSize(value.lapCount) +
        FfiConverterFloat64.allocationSize(value.bestTime) +
        FfiConverterFloat64.allocationSize(value.bestPace) +
        FfiConverterFloat64.allocationSize(value.avgTime) +
        FfiConverterFloat64.allocationSize(value.avgPace) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterFloat64.allocationSize(value.sectionDistance)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Complete section performance result.
 */
export type SectionPerformanceResult = {
  /**
   * Performance records sorted by date (oldest first)
   */
  records: Array<SectionPerformanceRecord>;
  /**
   * Best record (fastest time)
   */
  bestRecord: SectionPerformanceRecord | undefined;
};

/**
 * Generated factory for {@link SectionPerformanceResult} record objects.
 */
export const SectionPerformanceResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SectionPerformanceResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionPerformanceResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionPerformanceResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SectionPerformanceResult>,
  });
})();

const FfiConverterTypeSectionPerformanceResult = (() => {
  type TypeName = SectionPerformanceResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        records: FfiConverterArrayTypeSectionPerformanceRecord.read(from),
        bestRecord: FfiConverterOptionalTypeSectionPerformanceRecord.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeSectionPerformanceRecord.write(value.records, into);
      FfiConverterOptionalTypeSectionPerformanceRecord.write(
        value.bestRecord,
        into,
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeSectionPerformanceRecord.allocationSize(
          value.records,
        ) +
        FfiConverterOptionalTypeSectionPerformanceRecord.allocationSize(
          value.bestRecord,
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Each activity's portion of a section (for pace comparison)
 */
export type SectionPortion = {
  /**
   * Activity ID
   */
  activityId: string;
  /**
   * Start index into the activity's FULL GPS track
   */
  startIndex: /*u32*/ number;
  /**
   * End index into the activity's FULL GPS track
   */
  endIndex: /*u32*/ number;
  /**
   * Distance of this portion in meters
   */
  distanceMeters: /*f64*/ number;
  /**
   * Direction relative to representative: "same" or "reverse"
   */
  direction: string;
};

/**
 * Generated factory for {@link SectionPortion} record objects.
 */
export const SectionPortion = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SectionPortion, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionPortion}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionPortion}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SectionPortion>,
  });
})();

const FfiConverterTypeSectionPortion = (() => {
  type TypeName = SectionPortion;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterString.write(value.direction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterString.allocationSize(value.direction)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of splitting a section
 */
export type SplitResult = {
  /**
   * The first part of the split section
   */
  first: FrequentSection;
  /**
   * The second part of the split section
   */
  second: FrequentSection;
};

/**
 * Generated factory for {@link SplitResult} record objects.
 */
export const SplitResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SplitResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SplitResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SplitResult}, with defaults specified
     * in Rust, in the {@link tracematch} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link tracematch} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SplitResult>,
  });
})();

const FfiConverterTypeSplitResult = (() => {
  type TypeName = SplitResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        first: FfiConverterTypeFrequentSection.read(from),
        second: FfiConverterTypeFrequentSection.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeFrequentSection.write(value.first, into);
      FfiConverterTypeFrequentSection.write(value.second, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeFrequentSection.allocationSize(value.first) +
        FfiConverterTypeFrequentSection.allocationSize(value.second)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status,
      ),
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status,
      ),
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status,
      ),
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// FfiConverter for Map<string, /*u32*/number>
const FfiConverterMapStringUInt32 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterUInt32,
);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64,
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for Bounds | undefined
const FfiConverterOptionalTypeBounds = new FfiConverterOptional(
  FfiConverterTypeBounds,
);

// FfiConverter for CellQueryResult | undefined
const FfiConverterOptionalTypeCellQueryResult = new FfiConverterOptional(
  FfiConverterTypeCellQueryResult,
);

// FfiConverter for HeatmapBounds | undefined
const FfiConverterOptionalTypeHeatmapBounds = new FfiConverterOptional(
  FfiConverterTypeHeatmapBounds,
);

// FfiConverter for MatchResult | undefined
const FfiConverterOptionalTypeMatchResult = new FfiConverterOptional(
  FfiConverterTypeMatchResult,
);

// FfiConverter for PersistentEngineStats | undefined
const FfiConverterOptionalTypePersistentEngineStats = new FfiConverterOptional(
  FfiConverterTypePersistentEngineStats,
);

// FfiConverter for RoutePerformance | undefined
const FfiConverterOptionalTypeRoutePerformance = new FfiConverterOptional(
  FfiConverterTypeRoutePerformance,
);

// FfiConverter for RouteSignature | undefined
const FfiConverterOptionalTypeRouteSignature = new FfiConverterOptional(
  FfiConverterTypeRouteSignature,
);

// FfiConverter for SectionPerformanceRecord | undefined
const FfiConverterOptionalTypeSectionPerformanceRecord =
  new FfiConverterOptional(FfiConverterTypeSectionPerformanceRecord);

// FfiConverter for SplitResult | undefined
const FfiConverterOptionalTypeSplitResult = new FfiConverterOptional(
  FfiConverterTypeSplitResult,
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u16*/number | undefined
const FfiConverterOptionalUInt16 = new FfiConverterOptional(FfiConverterUInt16);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for Array</*f64*/number>
const FfiConverterArrayFloat64 = new FfiConverterArray(FfiConverterFloat64);

// FfiConverter for Array<ActivityHeatmapData>
const FfiConverterArrayTypeActivityHeatmapData = new FfiConverterArray(
  FfiConverterTypeActivityHeatmapData,
);

// FfiConverter for Array<ActivityMetrics>
const FfiConverterArrayTypeActivityMetrics = new FfiConverterArray(
  FfiConverterTypeActivityMetrics,
);

// FfiConverter for Array<ActivitySportType>
const FfiConverterArrayTypeActivitySportType = new FfiConverterArray(
  FfiConverterTypeActivitySportType,
);

// FfiConverter for Array<FfiActivityMapResult>
const FfiConverterArrayTypeFfiActivityMapResult = new FfiConverterArray(
  FfiConverterTypeFfiActivityMapResult,
);

// FfiConverter for Array<FlatGpsTrack>
const FfiConverterArrayTypeFlatGpsTrack = new FfiConverterArray(
  FfiConverterTypeFlatGpsTrack,
);

// FfiConverter for Array<FrequentSection>
const FfiConverterArrayTypeFrequentSection = new FfiConverterArray(
  FfiConverterTypeFrequentSection,
);

// FfiConverter for Array<GpsPoint>
const FfiConverterArrayTypeGpsPoint = new FfiConverterArray(
  FfiConverterTypeGpsPoint,
);

// FfiConverter for Array<HeatmapCell>
const FfiConverterArrayTypeHeatmapCell = new FfiConverterArray(
  FfiConverterTypeHeatmapCell,
);

// FfiConverter for Array<PotentialSection>
const FfiConverterArrayTypePotentialSection = new FfiConverterArray(
  FfiConverterTypePotentialSection,
);

// FfiConverter for Array<RouteGroup>
const FfiConverterArrayTypeRouteGroup = new FfiConverterArray(
  FfiConverterTypeRouteGroup,
);

// FfiConverter for Array<RoutePerformance>
const FfiConverterArrayTypeRoutePerformance = new FfiConverterArray(
  FfiConverterTypeRoutePerformance,
);

// FfiConverter for Array<RouteRef>
const FfiConverterArrayTypeRouteRef = new FfiConverterArray(
  FfiConverterTypeRouteRef,
);

// FfiConverter for Array<RouteSignature>
const FfiConverterArrayTypeRouteSignature = new FfiConverterArray(
  FfiConverterTypeRouteSignature,
);

// FfiConverter for Array<ScalePreset>
const FfiConverterArrayTypeScalePreset = new FfiConverterArray(
  FfiConverterTypeScalePreset,
);

// FfiConverter for Array<SectionLap>
const FfiConverterArrayTypeSectionLap = new FfiConverterArray(
  FfiConverterTypeSectionLap,
);

// FfiConverter for Array<SectionMatch>
const FfiConverterArrayTypeSectionMatch = new FfiConverterArray(
  FfiConverterTypeSectionMatch,
);

// FfiConverter for Array<SectionPerformanceRecord>
const FfiConverterArrayTypeSectionPerformanceRecord = new FfiConverterArray(
  FfiConverterTypeSectionPerformanceRecord,
);

// FfiConverter for Array<SectionPortion>
const FfiConverterArrayTypeSectionPortion = new FfiConverterArray(
  FfiConverterTypeSectionPortion,
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u32*/number>
const FfiConverterArrayUInt32 = new FfiConverterArray(FfiConverterUInt32);

// FfiConverter for Map<string, Array<GpsPoint>>
const FfiConverterMapStringArrayTypeGpsPoint = new FfiConverterMap(
  FfiConverterString,
  FfiConverterArrayTypeGpsPoint,
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_tracematch_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_conservative_section_config() !==
    44484
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_conservative_section_config",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_create_signature() !==
    34980
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_create_signature",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_create_signature_with_config() !==
    4764
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_create_signature_with_config",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_create_signatures_from_flat() !==
    13757
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_create_signatures_from_flat",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_default_config() !==
    60146
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_default_config",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_default_custom_section_match_config() !==
    38925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_default_custom_section_match_config",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_default_scale_presets() !==
    6194
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_default_scale_presets",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_fetch_activity_maps() !==
    8460
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_fetch_activity_maps",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_fetch_activity_maps_with_progress() !==
    44477
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_fetch_activity_maps_with_progress",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_compare_routes() !==
    17282
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_compare_routes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_detect_sections_multiscale() !==
    46737
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_detect_sections_multiscale",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_detect_sections_optimized() !==
    42847
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_detect_sections_optimized",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_find_sections_in_route() !==
    4802
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_find_sections_in_route",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_generate_heatmap() !==
    44771
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_generate_heatmap",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_group_incremental() !==
    37620
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_group_incremental",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_group_signatures() !==
    7624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_group_signatures",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_query_heatmap_cell() !==
    6800
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_query_heatmap_cell",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_recalculate_section_polyline() !==
    31041
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_recalculate_section_polyline",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_split_section_at_index() !==
    24818
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_split_section_at_index",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_ffi_split_section_at_point() !==
    48700
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_ffi_split_section_at_point",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_legacy_section_config() !==
    44917
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_legacy_section_config",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_add_activities() !==
    49919
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_add_activities",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_add_custom_section() !==
    65255
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_add_custom_section",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_cancel_section_detection() !==
    33387
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_cancel_section_detection",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_cleanup_old_activities() !==
    27067
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_cleanup_old_activities",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_clear() !==
    4645
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_clear",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_extract_section_trace() !==
    23289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_extract_section_trace",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_activity_count() !==
    23990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_activity_count",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_activity_ids() !==
    56293
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_activity_ids",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_all_activity_bounds_json() !==
    40823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_all_activity_bounds_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_all_route_names_json() !==
    58687
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_all_route_names_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_all_section_names_json() !==
    21357
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_all_section_names_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_consensus_route() !==
    13373
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_consensus_route",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_custom_section_matches() !==
    37527
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_custom_section_matches",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_custom_sections_json() !==
    51675
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_custom_sections_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_gps_track() !==
    20251
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_gps_track",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_groups_json() !==
    40609
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_groups_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_route_name() !==
    25470
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_route_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_route_performances_json() !==
    55134
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_route_performances_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_section_detection_progress() !==
    37519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_section_detection_progress",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_section_name() !==
    63920
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_section_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_section_performances_json() !==
    43523
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_section_performances_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_sections_json() !==
    7810
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_sections_json",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_get_stats() !==
    15398
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_get_stats",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_init() !==
    13040
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_init",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_is_initialized() !==
    20496
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_is_initialized",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_mark_for_recomputation() !==
    8545
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_mark_for_recomputation",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_match_custom_section() !==
    25570
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_match_custom_section",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_poll_sections() !==
    51299
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_poll_sections",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_query_viewport() !==
    35857
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_query_viewport",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_remove_activities() !==
    57689
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_remove_activities",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_remove_custom_section() !==
    20216
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_remove_custom_section",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_set_activity_metrics() !==
    64571
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_set_activity_metrics",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_set_route_name() !==
    55777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_set_route_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_set_section_name() !==
    34294
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_set_section_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_set_time_streams_flat() !==
    47396
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_set_time_streams_flat",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_persistent_engine_start_section_detection() !==
    30400
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_persistent_engine_start_section_detection",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_func_process_routes_from_flat() !==
    49526
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_func_process_routes_from_flat",
    );
  }
  if (
    nativeModule().ubrn_uniffi_tracematch_checksum_method_fetchprogresscallback_on_progress() !==
    36192
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_tracematch_checksum_method_fetchprogresscallback_on_progress",
    );
  }

  uniffiCallbackInterfaceFetchProgressCallback.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeActivityHeatmapData,
    FfiConverterTypeActivityMetrics,
    FfiConverterTypeActivitySportType,
    FfiConverterTypeBounds,
    FfiConverterTypeCellQueryResult,
    FfiConverterTypeCustomSection,
    FfiConverterTypeCustomSectionMatch,
    FfiConverterTypeCustomSectionMatchConfig,
    FfiConverterTypeDetectionStats,
    FfiConverterTypeFfiActivityMapResult,
    FfiConverterTypeFlatGpsTrack,
    FfiConverterTypeFrequentSection,
    FfiConverterTypeGpsPoint,
    FfiConverterTypeHeatmapBounds,
    FfiConverterTypeHeatmapCell,
    FfiConverterTypeHeatmapConfig,
    FfiConverterTypeHeatmapResult,
    FfiConverterTypeMatchConfig,
    FfiConverterTypeMatchResult,
    FfiConverterTypeMultiScaleSectionResult,
    FfiConverterTypePersistentEngineStats,
    FfiConverterTypePotentialSection,
    FfiConverterTypeRouteGroup,
    FfiConverterTypeRoutePerformance,
    FfiConverterTypeRoutePerformanceResult,
    FfiConverterTypeRouteRef,
    FfiConverterTypeRouteSignature,
    FfiConverterTypeScalePreset,
    FfiConverterTypeSectionConfig,
    FfiConverterTypeSectionLap,
    FfiConverterTypeSectionMatch,
    FfiConverterTypeSectionPerformanceRecord,
    FfiConverterTypeSectionPerformanceResult,
    FfiConverterTypeSectionPortion,
    FfiConverterTypeSplitResult,
  },
});
