// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceFetchProgressCallback,
} from "./veloqrs-ffi";
import {
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiReferenceHolder,
  type UniffiRustCallStatus,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt8,
  RustBuffer,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTraitInterfaceCall,
} from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

/**
 * Compute what fraction of polylineA's points are within `threshold_meters` of any point in polylineB.
 * Both polylines are flat coordinate arrays [lat, lng, lat, lng, ...].
 * Uses an R-tree on polylineB for O(n log m) instead of O(n*m).
 * Returns 0.0-1.0.
 */
export function computePolylineOverlap(
  coordsA: Array</*f64*/ number>,
  coordsB: Array</*f64*/ number>,
  thresholdMeters: /*f64*/ number,
): /*f64*/ number {
  return FfiConverterFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_compute_polyline_overlap(
          FfiConverterArrayFloat64.lower(coordsA),
          FfiConverterArrayFloat64.lower(coordsB),
          FfiConverterFloat64.lower(thresholdMeters),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Create a new section.
 *
 * # Arguments
 * * `sport_type` - Activity type (cycling, running, etc.)
 * * `polyline_json` - JSON array of GpsPoint coordinates
 * * `distance_meters` - Total section distance
 * * `name` - Optional section name
 * * `source_activity_id` - Source activity ID (required for custom sections)
 * * `start_index` - Start index in source activity (custom sections)
 * * `end_index` - End index in source activity (custom sections)
 *
 * # Returns
 * The created section ID, or empty string on error
 */
export function createSection(
  sportType: string,
  polylineJson: string,
  distanceMeters: /*f64*/ number,
  name: string | undefined,
  sourceActivityId: string | undefined,
  startIndex: /*u32*/ number | undefined,
  endIndex: /*u32*/ number | undefined,
): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_create_section(
          FfiConverterString.lower(sportType),
          FfiConverterString.lower(polylineJson),
          FfiConverterFloat64.lower(distanceMeters),
          FfiConverterOptionalString.lower(name),
          FfiConverterOptionalString.lower(sourceActivityId),
          FfiConverterOptionalUInt32.lower(startIndex),
          FfiConverterOptionalUInt32.lower(endIndex),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get default scale presets for multi-scale detection
 */
export function defaultScalePresets(): Array<FfiScalePreset> {
  return FfiConverterArrayTypeFfiScalePreset.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_default_scale_presets(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Delete a section.
 *
 * # Arguments
 * * `section_id` - Section ID to delete
 *
 * # Returns
 * true on success, false on error
 */
export function deleteSection(sectionId: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_delete_section(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Fetch map data for multiple activities.
 *
 * The auth_header should be a pre-formatted Authorization header value:
 * - For API key auth: "Basic {base64(API_KEY:key)}"
 * - For OAuth: "Bearer {access_token}"
 */
export function fetchActivityMaps(
  authHeader: string,
  activityIds: Array<string>,
): Array<FfiActivityMapResult> {
  return FfiConverterArrayTypeFfiActivityMapResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_fetch_activity_maps(
          FfiConverterString.lower(authHeader),
          FfiConverterArrayString.lower(activityIds),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Fetch map data with real-time progress callbacks.
 *
 * Same as fetch_activity_maps but calls the progress callback after each
 * activity is fetched, allowing the UI to show real-time progress.
 *
 * NOTE: The callback is invoked from tokio worker threads. This may cause
 * crashes with some FFI runtimes (like React Native's Hermes) that aren't
 * thread-safe. Use fetch_activity_maps without callback if you experience crashes.
 *
 * The auth_header should be a pre-formatted Authorization header value:
 * - For API key auth: "Basic {base64(API_KEY:key)}"
 * - For OAuth: "Bearer {access_token}"
 */
export function fetchActivityMapsWithProgress(
  authHeader: string,
  activityIds: Array<string>,
  callback: FetchProgressCallback,
): Array<FfiActivityMapResult> {
  return FfiConverterArrayTypeFfiActivityMapResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_fetch_activity_maps_with_progress(
          FfiConverterString.lower(authHeader),
          FfiConverterArrayString.lower(activityIds),
          FfiConverterTypeFetchProgressCallback.lower(callback),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Detect sections at multiple scales with potential section suggestions.
 * This is the flagship entry point for section detection.
 *
 * Returns a MultiScaleSectionResult with:
 * - sections: Confirmed sections (meeting min_activities threshold)
 * - potentials: Suggested sections from 1-2 activity overlaps
 * - stats: Detection statistics
 */
export function ffiDetectSectionsMultiscale(
  activityIds: Array<string>,
  allCoords: Array</*f64*/ number>,
  offsets: Array</*u32*/ number>,
  sportTypes: Array<ActivitySportType>,
  groups: Array<FfiRouteGroup>,
  config: FfiSectionConfig,
): FfiMultiScaleSectionResult {
  return FfiConverterTypeFfiMultiScaleSectionResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_ffi_detect_sections_multiscale(
          FfiConverterArrayString.lower(activityIds),
          FfiConverterArrayFloat64.lower(allCoords),
          FfiConverterArrayUInt32.lower(offsets),
          FfiConverterArrayTypeActivitySportType.lower(sportTypes),
          FfiConverterArrayTypeFfiRouteGroup.lower(groups),
          FfiConverterTypeFfiSectionConfig.lower(config),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get current download progress for FFI polling.
 *
 * TypeScript should poll this every 100ms during fetch operations
 * to get smooth progress updates without cross-thread callback issues.
 *
 * Returns DownloadProgressResult with completed/total/active fields.
 * When active is false, the download has completed (or never started).
 */
export function getDownloadProgress(): DownloadProgressResult {
  return FfiConverterTypeDownloadProgressResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_get_download_progress(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get section count by type.
 *
 * # Arguments
 * * `section_type` - Optional filter: "auto", "custom", or None for all
 */
export function getSectionCount(
  sectionType: string | undefined,
): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_get_section_count(
          FfiConverterOptionalString.lower(sectionType),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get the reference activity ID for a section.
 *
 * # Arguments
 * * `section_id` - Section ID to query
 *
 * # Returns
 * The representative_activity_id, or empty string if not found
 */
export function getSectionReference(sectionId: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_get_section_reference(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get sections with optional type filter.
 *
 * # Arguments
 * * `section_type` - Optional filter: "auto", "custom", or None for all
 *
 * # Returns
 * Vec of FfiSection objects
 */
export function getSections(
  sectionType: string | undefined,
): Array<FfiSection> {
  return FfiConverterArrayTypeFfiSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_get_sections(
          FfiConverterOptionalString.lower(sectionType),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get sections for a specific activity.
 *
 * Uses junction table for efficient lookup.
 * Returns structured data instead of JSON string.
 *
 * # Arguments
 * * `activity_id` - Activity ID to find sections for
 *
 * # Returns
 * Vec of sections containing the activity
 */
export function getSectionsForActivity(activityId: string): Array<FfiSection> {
  return FfiConverterArrayTypeFfiSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_get_sections_for_activity(
          FfiConverterString.lower(activityId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Check if a section's reference is user-defined (vs algorithm-selected).
 *
 * # Arguments
 * * `section_id` - Section ID to query
 *
 * # Returns
 * true if user manually set the reference, false if algorithm-selected
 */
export function isSectionReferenceUserDefined(sectionId: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_is_section_reference_user_defined(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Add activities from flat coordinate buffers.
 * Coordinates are [lat1, lng1, lat2, lng2, ...] for each activity.
 */
export function persistentEngineAddActivities(
  activityIds: Array<string>,
  allCoords: Array</*f64*/ number>,
  offsets: Array</*u32*/ number>,
  sportTypes: Array<string>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_add_activities(
        FfiConverterArrayString.lower(activityIds),
        FfiConverterArrayFloat64.lower(allCoords),
        FfiConverterArrayUInt32.lower(offsets),
        FfiConverterArrayString.lower(sportTypes),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Remove activities older than the specified retention period.
 *
 * This prevents unbounded database growth by cleaning up old activities.
 * Cascade deletes automatically remove associated GPS tracks, signatures,
 * and match data. Groups and sections are marked for re-computation.
 *
 * # Arguments
 * * `retention_days` - Number of days to retain (0 = keep all, 30-365 for cleanup)
 *
 * # Returns
 * Number of activities deleted, or 0 if retention_days is 0
 */
export function persistentEngineCleanupOldActivities(
  retentionDays: /*u32*/ number,
): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_cleanup_old_activities(
          FfiConverterUInt32.lower(retentionDays),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Clear all persistent engine state.
 */
export function persistentEngineClear(): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_clear(
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Detect potential sections using GPS tracks from SQLite.
 * This eliminates the N+1 FFI call pattern - single call, all loading internal.
 * Returns JSON array of potential sections.
 */
export function persistentEngineDetectPotentials(
  sportFilter: string | undefined,
): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_detect_potentials(
          FfiConverterOptionalString.lower(sportFilter),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Extract the GPS trace for an activity that overlaps with a section polyline.
 * Returns a flat array of [lat, lng, lat, lng, ...] or empty if no overlap.
 */
export function persistentEngineExtractSectionTrace(
  activityId: string,
  sectionPolylineJson: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_extract_section_trace(
          FfiConverterString.lower(activityId),
          FfiConverterString.lower(sectionPolylineJson),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Extract section traces for multiple activities in a single FFI call.
 * Builds the R-tree from the section polyline ONCE, then processes each activity
 * sequentially — only one GPS track in memory at a time.
 * Returns flat coords per activity: Vec<(activity_id, [lat, lng, lat, lng, ...])>
 */
export function persistentEngineExtractSectionTracesBatch(
  activityIds: Array<string>,
  sectionPolylineJson: string,
): Array<FfiBatchTrace> {
  return FfiConverterArrayTypeFfiBatchTrace.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_extract_section_traces_batch(
          FfiConverterArrayString.lower(activityIds),
          FfiConverterString.lower(sectionPolylineJson),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Check which activities are missing cached time streams.
 * Returns activity IDs that need to be fetched from the API.
 */
export function persistentEngineGetActivitiesMissingTimeStreams(
  activityIds: Array<string>,
): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_activities_missing_time_streams(
          FfiConverterArrayString.lower(activityIds),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get activity count.
 */
export function persistentEngineGetActivityCount(): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_activity_count(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get activity heatmap data for a date range.
 * Returns Vec of (date string, intensity 0-4).
 */
export function persistentEngineGetActivityHeatmap(
  startTs: /*i64*/ bigint,
  endTs: /*i64*/ bigint,
): Array<FfiHeatmapDay> {
  return FfiConverterArrayTypeFfiHeatmapDay.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_activity_heatmap(
          FfiConverterInt64.lower(startTs),
          FfiConverterInt64.lower(endTs),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all activity IDs.
 */
export function persistentEngineGetActivityIds(): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_activity_ids(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get activity metrics for a list of activity IDs.
 * Returns metrics from the in-memory HashMap (O(1) per lookup).
 */
export function persistentEngineGetActivityMetricsForIds(
  ids: Array<string>,
): Array<FfiActivityMetrics> {
  return FfiConverterArrayTypeFfiActivityMetrics.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_activity_metrics_for_ids(
          FfiConverterArrayString.lower(ids),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all activities with complete data for map display.
 * Joins metadata (bounds) with metrics (name, date, distance) in a single call.
 * Much faster than fetching separately and merging in JS.
 */
export function persistentEngineGetAllMapActivitiesComplete(): Array<MapActivityComplete> {
  return FfiConverterArrayTypeMapActivityComplete.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_all_map_activities_complete(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all custom route names.
 * Returns a HashMap instead of JSON string.
 */
export function persistentEngineGetAllRouteNames(): Map<string, string> {
  return FfiConverterMapStringString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_all_route_names(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all section names.
 * Returns a HashMap instead of JSON string.
 */
export function persistentEngineGetAllSectionNames(): Map<string, string> {
  return FfiConverterMapStringString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_all_section_names(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get cached athlete profile JSON blob. Returns empty string if not cached.
 */
export function persistentEngineGetAthleteProfile(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_athlete_profile(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get distinct sport types from stored activities.
 */
export function persistentEngineGetAvailableSportTypes(): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_available_sport_types(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get consensus route for a group as flat coordinates.
 */
export function persistentEngineGetConsensusRoute(
  groupId: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_consensus_route(
          FfiConverterString.lower(groupId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get FTP trend: latest and previous distinct FTP values with dates.
 */
export function persistentEngineGetFtpTrend(): FfiFtpTrend {
  return FfiConverterTypeFfiFtpTrend.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_ftp_trend(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get GPS track for an activity as flat coordinates.
 */
export function persistentEngineGetGpsTrack(
  activityId: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_gps_track(
          FfiConverterString.lower(activityId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get a single group by ID (full data with activity IDs).
 */
export function persistentEngineGetGroupById(
  groupId: string,
): FfiRouteGroup | undefined {
  return FfiConverterOptionalTypeFfiRouteGroup.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_group_by_id(
          FfiConverterString.lower(groupId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get group count directly from SQLite (no data loading).
 */
export function persistentEngineGetGroupCount(): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_group_count(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get lightweight group summaries without full activity ID lists.
 */
export function persistentEngineGetGroupSummaries(): Array<GroupSummary> {
  return FfiConverterArrayTypeGroupSummary.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_group_summaries(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all route groups.
 */
export function persistentEngineGetGroups(): Array<FfiRouteGroup> {
  return FfiConverterArrayTypeFfiRouteGroup.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_groups(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get activities filtered by date range and optionally by sport types.
 * Performs filtering in Rust for maximum efficiency.
 *
 * Arguments:
 * - start_date: Unix timestamp (seconds) for start of range
 * - end_date: Unix timestamp (seconds) for end of range
 * - sport_types_json: JSON array of sport types to include, or empty string for all
 */
export function persistentEngineGetMapActivitiesFiltered(
  startDate: /*i64*/ bigint,
  endDate: /*i64*/ bigint,
  sportTypesJson: string,
): Array<MapActivityComplete> {
  return FfiConverterArrayTypeMapActivityComplete.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_map_activities_filtered(
          FfiConverterInt64.lower(startDate),
          FfiConverterInt64.lower(endDate),
          FfiConverterString.lower(sportTypesJson),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get monthly aggregates for a year.
 * metric: "hours" | "distance" | "tss"
 * Returns Vec of (month 0-11, value).
 */
export function persistentEngineGetMonthlyAggregates(
  year: /*i32*/ number,
  metric: string,
): Array<FfiMonthlyAggregate> {
  return FfiConverterArrayTypeFfiMonthlyAggregate.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_monthly_aggregates(
          FfiConverterInt32.lower(year),
          FfiConverterString.lower(metric),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get aggregated stats for a date range.
 * Returns count, total duration (seconds), total distance (meters), total TSS.
 */
export function persistentEngineGetPeriodStats(
  startTs: /*i64*/ bigint,
  endTs: /*i64*/ bigint,
): FfiPeriodStats {
  return FfiConverterTypeFfiPeriodStats.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_period_stats(
          FfiConverterInt64.lower(startTs),
          FfiConverterInt64.lower(endTs),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get the custom name for a route.
 * Returns empty string if no custom name is set.
 */
export function persistentEngineGetRouteName(routeId: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_route_name(
          FfiConverterString.lower(routeId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get route performances.
 * Returns structured data instead of JSON string.
 */
export function persistentEngineGetRoutePerformances(
  routeGroupId: string,
  currentActivityId: string | undefined,
): FfiRoutePerformanceResult {
  return FfiConverterTypeFfiRoutePerformanceResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_route_performances(
          FfiConverterString.lower(routeGroupId),
          FfiConverterOptionalString.lower(currentActivityId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all data for the Routes screen in a single FFI call.
 * Supports pagination via limit/offset for groups and sections.
 */
export function persistentEngineGetRoutesScreenData(
  groupLimit: /*u32*/ number,
  groupOffset: /*u32*/ number,
  sectionLimit: /*u32*/ number,
  sectionOffset: /*u32*/ number,
): FfiRoutesScreenData | undefined {
  return FfiConverterOptionalTypeFfiRoutesScreenData.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_routes_screen_data(
          FfiConverterUInt32.lower(groupLimit),
          FfiConverterUInt32.lower(groupOffset),
          FfiConverterUInt32.lower(sectionLimit),
          FfiConverterUInt32.lower(sectionOffset),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get a single section by ID (full data with polyline).
 */
export function persistentEngineGetSectionById(
  sectionId: string,
): FfiFrequentSection | undefined {
  return FfiConverterOptionalTypeFfiFrequentSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_by_id(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get section count directly from SQLite (no data loading).
 */
export function persistentEngineGetSectionCount(): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_count(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get current section detection progress.
 * Returns JSON with format: {"phase": "finding_overlaps", "completed": 45, "total": 120}
 * Returns empty JSON "{}" if no detection is running.
 */
export function persistentEngineGetSectionDetectionProgress(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_detection_progress(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get section performances.
 * Returns structured data instead of JSON string.
 */
export function persistentEngineGetSectionPerformances(
  sectionId: string,
): FfiSectionPerformanceResult {
  return FfiConverterTypeFfiSectionPerformanceResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_performances(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get section polyline only (flat coordinates for map rendering).
 */
export function persistentEngineGetSectionPolyline(
  sectionId: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_polyline(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get lightweight section summaries without polyline data.
 */
export function persistentEngineGetSectionSummaries(): Array<SectionSummary> {
  return FfiConverterArrayTypeSectionSummary.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_summaries(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get section summaries filtered by sport type.
 */
export function persistentEngineGetSectionSummariesForSport(
  sportType: string,
): Array<SectionSummary> {
  return FfiConverterArrayTypeSectionSummary.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_section_summaries_for_sport(
          FfiConverterString.lower(sportType),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get all sections with full data (including polylines).
 */
export function persistentEngineGetSections(): Array<FfiFrequentSection> {
  return FfiConverterArrayTypeFfiFrequentSection.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_sections(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get cached sport settings JSON blob. Returns empty string if not cached.
 */
export function persistentEngineGetSportSettings(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_sport_settings(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get engine statistics.
 */
export function persistentEngineGetStats(): PersistentEngineStats | undefined {
  return FfiConverterOptionalTypePersistentEngineStats.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_stats(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get aggregated zone distribution for a sport type.
 * zone_type: "power" | "hr"
 * Returns flat array of total seconds per zone.
 */
export function persistentEngineGetZoneDistribution(
  sportType: string,
  zoneType: string,
): Array</*f64*/ number> {
  return FfiConverterArrayFloat64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_get_zone_distribution(
          FfiConverterString.lower(sportType),
          FfiConverterString.lower(zoneType),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Initialize the persistent engine with a database path.
 * Call this once at app startup before any other persistent engine functions.
 */
export function persistentEngineInit(dbPath: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_init(
          FfiConverterString.lower(dbPath),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Check if the persistent engine is initialized.
 */
export function persistentEngineIsInitialized(): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_is_initialized(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Mark route engine for re-computation.
 *
 * Call this when historical activities are added (e.g., cache expansion)
 * to trigger re-computation of route groups and sections with the new data.
 */
export function persistentEngineMarkForRecomputation(): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_mark_for_recomputation(
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Poll for section detection completion.
 * Returns:
 * - "running" if detection is still in progress
 * - "complete" if detection finished and sections were applied
 * - "idle" if no detection is running
 * - "error" if detection failed
 */
export function persistentEnginePollSections(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_poll_sections(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Query activities in viewport.
 */
export function persistentEngineQueryViewport(
  minLat: /*f64*/ number,
  maxLat: /*f64*/ number,
  minLng: /*f64*/ number,
  maxLng: /*f64*/ number,
): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_query_viewport(
          FfiConverterFloat64.lower(minLat),
          FfiConverterFloat64.lower(maxLat),
          FfiConverterFloat64.lower(minLng),
          FfiConverterFloat64.lower(maxLng),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Get the name for a section.
 * Set activity metrics for performance calculations (with extended fields for aggregation).
 */
export function persistentEngineSetActivityMetrics(
  metrics: Array<FfiActivityMetrics>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_activity_metrics(
        FfiConverterArrayTypeFfiActivityMetrics.lower(metrics),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Store athlete profile JSON blob in SQLite for instant startup rendering.
 */
export function persistentEngineSetAthleteProfile(json: string): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_athlete_profile(
        FfiConverterString.lower(json),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set translations for auto-generated route/section names.
 * Call this after i18n is initialized and whenever language changes.
 *
 * # Arguments
 * * `route_word` - Translated word for "Route" (e.g., "Route", "Ruta", "Strecke")
 * * `section_word` - Translated word for "Section" (e.g., "Section", "Sección", "Abschnitt")
 */
export function persistentEngineSetNameTranslations(
  routeWord: string,
  sectionWord: string,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_name_translations(
        FfiConverterString.lower(routeWord),
        FfiConverterString.lower(sectionWord),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set a custom name for a route.
 * Pass empty string to clear the custom name.
 */
export function persistentEngineSetRouteName(
  routeId: string,
  name: string,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_route_name(
        FfiConverterString.lower(routeId),
        FfiConverterString.lower(name),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set the name for a section.
 * Pass empty string to clear the name.
 */
export function persistentEngineSetSectionName(
  sectionId: string,
  name: string,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_section_name(
        FfiConverterString.lower(sectionId),
        FfiConverterString.lower(name),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Store sport settings JSON blob in SQLite for instant startup rendering.
 */
export function persistentEngineSetSportSettings(json: string): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_sport_settings(
        FfiConverterString.lower(json),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Set time streams for activities from flat buffer.
 * Time streams are cumulative seconds at each GPS point, used for section performance calculations.
 * Parameters:
 * - activity_ids: Vec of activity IDs
 * - all_times: Flat array of all time values concatenated
 * - offsets: Start offset for each activity's times in all_times (length = activity_ids.len() + 1)
 */
export function persistentEngineSetTimeStreamsFlat(
  activityIds: Array<string>,
  allTimes: Array</*u32*/ number>,
  offsets: Array</*u32*/ number>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_set_time_streams_flat(
        FfiConverterArrayString.lower(activityIds),
        FfiConverterArrayUInt32.lower(allTimes),
        FfiConverterArrayUInt32.lower(offsets),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Start section detection in the background.
 * Returns true if detection was started, false if already running or engine not initialized.
 */
export function persistentEngineStartSectionDetection(
  sportFilter: string | undefined,
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_persistent_engine_start_section_detection(
          FfiConverterOptionalString.lower(sportFilter),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Rename a section.
 *
 * # Arguments
 * * `section_id` - Section ID to rename
 * * `name` - New name
 *
 * # Returns
 * true on success, false on error
 */
export function renameSection(sectionId: string, name: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_rename_section(
          FfiConverterString.lower(sectionId),
          FfiConverterString.lower(name),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Reset a section's reference to automatic (algorithm-selected).
 * Sets is_user_defined to false.
 *
 * # Arguments
 * * `section_id` - Section ID to reset
 *
 * # Returns
 * true on success, false on error
 */
export function resetSectionReference(sectionId: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_reset_section_reference(
          FfiConverterString.lower(sectionId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Set a new reference activity for a section.
 *
 * Updates the representative_activity_id and reloads the polyline from the activity.
 *
 * # Arguments
 * * `section_id` - Section ID to update
 * * `activity_id` - New reference activity ID
 *
 * # Returns
 * true on success, false on error
 */
export function setSectionReference(
  sectionId: string,
  activityId: string,
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_set_section_reference(
          FfiConverterString.lower(sectionId),
          FfiConverterString.lower(activityId),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Start a non-blocking background fetch.
 *
 * This returns immediately and the fetch runs in a background thread.
 * Poll get_download_progress() to monitor progress.
 * When active becomes false, call take_background_fetch_results() to get the data.
 *
 * This is preferred over fetch_activity_maps() for UI responsiveness as it
 * doesn't block the JavaScript thread.
 */
export function startBackgroundFetch(
  authHeader: string,
  activityIds: Array<string>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_start_background_fetch(
        FfiConverterString.lower(authHeader),
        FfiConverterArrayString.lower(activityIds),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Start a background fetch that downloads GPS data and stores it directly
 * in the persistent engine. This eliminates the FFI round-trip where GPS
 * data would otherwise be sent to TypeScript and back.
 *
 * Poll get_download_progress() to monitor progress.
 * When active becomes false, call take_fetch_and_store_result() to get the result.
 *
 * This is ~3x faster than the separate fetch + addActivities approach because:
 * - No ~1.7MB GPS data transfer from Rust to TypeScript
 * - No ~865KB GPS data transfer from TypeScript back to Rust
 * - Direct storage in SQLite without serialization overhead
 */
export function startFetchAndStore(
  authHeader: string,
  activityIds: Array<string>,
  sportTypes: Array<ActivitySportMapping>,
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_veloqrs_fn_func_start_fetch_and_store(
        FfiConverterString.lower(authHeader),
        FfiConverterArrayString.lower(activityIds),
        FfiConverterArrayTypeActivitySportMapping.lower(sportTypes),
        callStatus,
      );
    },
    /*liftString:*/ FfiConverterString.lift,
  );
}
/**
 * Take the results from a completed background fetch.
 *
 * Returns None if fetch is still in progress (check get_download_progress().active).
 * Returns the results and clears storage when complete.
 * Each call after completion returns None until a new fetch is started.
 */
export function takeBackgroundFetchResults():
  | Array<FfiActivityMapResult>
  | undefined {
  return FfiConverterOptionalArrayTypeFfiActivityMapResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_take_background_fetch_results(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Take the result from a completed fetch+store operation.
 *
 * Returns None if operation is still in progress.
 * Returns the result and clears storage when complete.
 */
export function takeFetchAndStoreResult(): FetchAndStoreResult | undefined {
  return FfiConverterOptionalTypeFetchAndStoreResult.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_veloqrs_fn_func_take_fetch_and_store_result(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}

/**
 * Callback interface for receiving progress updates during fetch operations.
 * Implement this in TypeScript/Kotlin/Swift to receive real-time updates.
 */
export interface FetchProgressCallback {
  /**
   * Called when a single activity fetch completes.
   * - completed: Number of activities fetched so far
   * - total: Total number of activities to fetch
   */
  onProgress(completed: /*u32*/ number, total: /*u32*/ number): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFetchProgressCallback: {
  vtable: UniffiVTableCallbackInterfaceFetchProgressCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onProgress: (uniffiHandle: bigint, completed: number, total: number) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFetchProgressCallback.lift(uniffiHandle);
        return jsCallback.onProgress(
          FfiConverterUInt32.lift(completed),
          FfiConverterUInt32.lift(total),
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower,
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FetchProgressCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFetchProgressCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_veloqrs_fn_init_callback_vtable_fetchprogresscallback(
      uniffiCallbackInterfaceFetchProgressCallback.vtable,
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeFetchProgressCallback =
  new FfiConverterCallback<FetchProgressCallback>();

/**
 * Result of matching an activity track against existing sections.
 * This is used for incremental section updates when a new activity is added.
 *
 * Note: overlap_points is not included because Vec<GpsPoint> can't be
 * exported via UniFFI. Use start_index/end_index to extract from original track.
 */
export type ActivitySectionMatch = {
  /**
   * Section ID that was matched
   */
  sectionId: string;
  /**
   * Section name (if set)
   */
  sectionName: string | undefined;
  /**
   * Distance of the overlapping portion in meters
   */
  overlapDistance: /*f64*/ number;
  /**
   * Start index in the original track
   */
  startIndex: /*u32*/ number;
  /**
   * End index in the original track
   */
  endIndex: /*u32*/ number;
  /**
   * Match quality (0.0 to 1.0)
   */
  matchQuality: /*f64*/ number;
  /**
   * Whether the activity goes in the same direction as the section
   */
  sameDirection: boolean;
};

/**
 * Generated factory for {@link ActivitySectionMatch} record objects.
 */
export const ActivitySectionMatch = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ActivitySectionMatch,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ActivitySectionMatch}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ActivitySectionMatch}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ActivitySectionMatch>,
  });
})();

const FfiConverterTypeActivitySectionMatch = (() => {
  type TypeName = ActivitySectionMatch;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sectionId: FfiConverterString.read(from),
        sectionName: FfiConverterOptionalString.read(from),
        overlapDistance: FfiConverterFloat64.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
        matchQuality: FfiConverterFloat64.read(from),
        sameDirection: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.sectionId, into);
      FfiConverterOptionalString.write(value.sectionName, into);
      FfiConverterFloat64.write(value.overlapDistance, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
      FfiConverterFloat64.write(value.matchQuality, into);
      FfiConverterBool.write(value.sameDirection, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.sectionId) +
        FfiConverterOptionalString.allocationSize(value.sectionName) +
        FfiConverterFloat64.allocationSize(value.overlapDistance) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex) +
        FfiConverterFloat64.allocationSize(value.matchQuality) +
        FfiConverterBool.allocationSize(value.sameDirection)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Sport type mapping for activities.
 */
export type ActivitySportMapping = {
  activityId: string;
  sportType: string;
};

/**
 * Generated factory for {@link ActivitySportMapping} record objects.
 */
export const ActivitySportMapping = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ActivitySportMapping,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ActivitySportMapping}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ActivitySportMapping}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ActivitySportMapping>,
  });
})();

const FfiConverterTypeActivitySportMapping = (() => {
  type TypeName = ActivitySportMapping;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.sportType, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.sportType)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Input mapping activity IDs to sport types
 */
export type ActivitySportType = {
  activityId: string;
  sportType: string;
};

/**
 * Generated factory for {@link ActivitySportType} record objects.
 */
export const ActivitySportType = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ActivitySportType, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ActivitySportType}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ActivitySportType}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ActivitySportType>,
  });
})();

const FfiConverterTypeActivitySportType = (() => {
  type TypeName = ActivitySportType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.sportType, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.sportType)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of polling download progress.
 * Used by TypeScript to show real-time progress without cross-thread callbacks.
 */
export type DownloadProgressResult = {
  /**
   * Number of activities fetched so far
   */
  completed: /*u32*/ number;
  /**
   * Total number of activities to fetch
   */
  total: /*u32*/ number;
  /**
   * Whether a download is currently active
   */
  active: boolean;
};

/**
 * Generated factory for {@link DownloadProgressResult} record objects.
 */
export const DownloadProgressResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      DownloadProgressResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DownloadProgressResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DownloadProgressResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<DownloadProgressResult>,
  });
})();

const FfiConverterTypeDownloadProgressResult = (() => {
  type TypeName = DownloadProgressResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        completed: FfiConverterUInt32.read(from),
        total: FfiConverterUInt32.read(from),
        active: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.completed, into);
      FfiConverterUInt32.write(value.total, into);
      FfiConverterBool.write(value.active, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.completed) +
        FfiConverterUInt32.allocationSize(value.total) +
        FfiConverterBool.allocationSize(value.active)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of the combined fetch and store operation.
 */
export type FetchAndStoreResult = {
  /**
   * Activity IDs that were successfully fetched and stored
   */
  syncedIds: Array<string>;
  /**
   * Activity IDs that failed to fetch
   */
  failedIds: Array<string>;
  /**
   * Total number of activities processed
   */
  total: /*u32*/ number;
  /**
   * Number successfully synced
   */
  successCount: /*u32*/ number;
  /**
   * Total GPS points stored
   */
  totalPoints: /*u32*/ number;
  /**
   * Time to fetch all GPS data (ms)
   */
  fetchTimeMs: /*u32*/ number;
  /**
   * Time to store in SQLite (ms)
   */
  storageTimeMs: /*u32*/ number;
  /**
   * Total thread time (ms)
   */
  totalTimeMs: /*u32*/ number;
};

/**
 * Generated factory for {@link FetchAndStoreResult} record objects.
 */
export const FetchAndStoreResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FetchAndStoreResult, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FetchAndStoreResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FetchAndStoreResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FetchAndStoreResult>,
  });
})();

const FfiConverterTypeFetchAndStoreResult = (() => {
  type TypeName = FetchAndStoreResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        syncedIds: FfiConverterArrayString.read(from),
        failedIds: FfiConverterArrayString.read(from),
        total: FfiConverterUInt32.read(from),
        successCount: FfiConverterUInt32.read(from),
        totalPoints: FfiConverterUInt32.read(from),
        fetchTimeMs: FfiConverterUInt32.read(from),
        storageTimeMs: FfiConverterUInt32.read(from),
        totalTimeMs: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.syncedIds, into);
      FfiConverterArrayString.write(value.failedIds, into);
      FfiConverterUInt32.write(value.total, into);
      FfiConverterUInt32.write(value.successCount, into);
      FfiConverterUInt32.write(value.totalPoints, into);
      FfiConverterUInt32.write(value.fetchTimeMs, into);
      FfiConverterUInt32.write(value.storageTimeMs, into);
      FfiConverterUInt32.write(value.totalTimeMs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.syncedIds) +
        FfiConverterArrayString.allocationSize(value.failedIds) +
        FfiConverterUInt32.allocationSize(value.total) +
        FfiConverterUInt32.allocationSize(value.successCount) +
        FfiConverterUInt32.allocationSize(value.totalPoints) +
        FfiConverterUInt32.allocationSize(value.fetchTimeMs) +
        FfiConverterUInt32.allocationSize(value.storageTimeMs) +
        FfiConverterUInt32.allocationSize(value.totalTimeMs)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Result of fetching activity map data from intervals.icu
 */
export type FfiActivityMapResult = {
  activityId: string;
  /**
   * Bounds as [ne_lat, ne_lng, sw_lat, sw_lng] or empty if no bounds
   */
  bounds: Array</*f64*/ number>;
  /**
   * GPS coordinates as flat array [lat1, lng1, lat2, lng2, ...]
   */
  latlngs: Array</*f64*/ number>;
  success: boolean;
  error: string | undefined;
};

/**
 * Generated factory for {@link FfiActivityMapResult} record objects.
 */
export const FfiActivityMapResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiActivityMapResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiActivityMapResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiActivityMapResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiActivityMapResult>,
  });
})();

const FfiConverterTypeFfiActivityMapResult = (() => {
  type TypeName = FfiActivityMapResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        bounds: FfiConverterArrayFloat64.read(from),
        latlngs: FfiConverterArrayFloat64.read(from),
        success: FfiConverterBool.read(from),
        error: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterArrayFloat64.write(value.bounds, into);
      FfiConverterArrayFloat64.write(value.latlngs, into);
      FfiConverterBool.write(value.success, into);
      FfiConverterOptionalString.write(value.error, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterArrayFloat64.allocationSize(value.bounds) +
        FfiConverterArrayFloat64.allocationSize(value.latlngs) +
        FfiConverterBool.allocationSize(value.success) +
        FfiConverterOptionalString.allocationSize(value.error)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Activity metrics for FFI
 */
export type FfiActivityMetrics = {
  activityId: string;
  name: string;
  /**
   * Unix timestamp (seconds since epoch)
   */
  date: /*i64*/ bigint;
  /**
   * Distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Moving time in seconds
   */
  movingTime: /*u32*/ number;
  /**
   * Elapsed time in seconds
   */
  elapsedTime: /*u32*/ number;
  /**
   * Total elevation gain in meters
   */
  elevationGain: /*f64*/ number;
  /**
   * Average heart rate (optional)
   */
  avgHr: /*u16*/ number | undefined;
  /**
   * Average power in watts (optional)
   */
  avgPower: /*u16*/ number | undefined;
  /**
   * Sport type (e.g., "Ride", "Run")
   */
  sportType: string;
  /**
   * Training load / TSS (optional)
   */
  trainingLoad: /*f64*/ number | undefined;
  /**
   * FTP used for this activity (optional)
   */
  ftp: /*u16*/ number | undefined;
  /**
   * Power zone times as JSON array string: "[secs, secs, ...]" (optional)
   */
  powerZoneTimes: string | undefined;
  /**
   * HR zone times as JSON array string: "[secs, secs, ...]" (optional)
   */
  hrZoneTimes: string | undefined;
};

/**
 * Generated factory for {@link FfiActivityMetrics} record objects.
 */
export const FfiActivityMetrics = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiActivityMetrics, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiActivityMetrics}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiActivityMetrics}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiActivityMetrics>,
  });
})();

const FfiConverterTypeFfiActivityMetrics = (() => {
  type TypeName = FfiActivityMetrics;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        date: FfiConverterInt64.read(from),
        distance: FfiConverterFloat64.read(from),
        movingTime: FfiConverterUInt32.read(from),
        elapsedTime: FfiConverterUInt32.read(from),
        elevationGain: FfiConverterFloat64.read(from),
        avgHr: FfiConverterOptionalUInt16.read(from),
        avgPower: FfiConverterOptionalUInt16.read(from),
        sportType: FfiConverterString.read(from),
        trainingLoad: FfiConverterOptionalFloat64.read(from),
        ftp: FfiConverterOptionalUInt16.read(from),
        powerZoneTimes: FfiConverterOptionalString.read(from),
        hrZoneTimes: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.name, into);
      FfiConverterInt64.write(value.date, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterUInt32.write(value.movingTime, into);
      FfiConverterUInt32.write(value.elapsedTime, into);
      FfiConverterFloat64.write(value.elevationGain, into);
      FfiConverterOptionalUInt16.write(value.avgHr, into);
      FfiConverterOptionalUInt16.write(value.avgPower, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterOptionalFloat64.write(value.trainingLoad, into);
      FfiConverterOptionalUInt16.write(value.ftp, into);
      FfiConverterOptionalString.write(value.powerZoneTimes, into);
      FfiConverterOptionalString.write(value.hrZoneTimes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterInt64.allocationSize(value.date) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterUInt32.allocationSize(value.movingTime) +
        FfiConverterUInt32.allocationSize(value.elapsedTime) +
        FfiConverterFloat64.allocationSize(value.elevationGain) +
        FfiConverterOptionalUInt16.allocationSize(value.avgHr) +
        FfiConverterOptionalUInt16.allocationSize(value.avgPower) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterOptionalFloat64.allocationSize(value.trainingLoad) +
        FfiConverterOptionalUInt16.allocationSize(value.ftp) +
        FfiConverterOptionalString.allocationSize(value.powerZoneTimes) +
        FfiConverterOptionalString.allocationSize(value.hrZoneTimes)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Batch trace result: one activity's extracted section trace as flat coords.
 */
export type FfiBatchTrace = {
  activityId: string;
  /**
   * Flat coordinates [lat, lng, lat, lng, ...]
   */
  coords: Array</*f64*/ number>;
};

/**
 * Generated factory for {@link FfiBatchTrace} record objects.
 */
export const FfiBatchTrace = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiBatchTrace, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiBatchTrace}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiBatchTrace}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiBatchTrace>,
  });
})();

const FfiConverterTypeFfiBatchTrace = (() => {
  type TypeName = FfiBatchTrace;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        coords: FfiConverterArrayFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterArrayFloat64.write(value.coords, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterArrayFloat64.allocationSize(value.coords)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Bounding box for FFI
 */
export type FfiBounds = {
  minLat: /*f64*/ number;
  maxLat: /*f64*/ number;
  minLng: /*f64*/ number;
  maxLng: /*f64*/ number;
};

/**
 * Generated factory for {@link FfiBounds} record objects.
 */
export const FfiBounds = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiBounds, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiBounds}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiBounds}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiBounds>,
  });
})();

const FfiConverterTypeFfiBounds = (() => {
  type TypeName = FfiBounds;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        minLat: FfiConverterFloat64.read(from),
        maxLat: FfiConverterFloat64.read(from),
        minLng: FfiConverterFloat64.read(from),
        maxLng: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.minLat, into);
      FfiConverterFloat64.write(value.maxLat, into);
      FfiConverterFloat64.write(value.minLng, into);
      FfiConverterFloat64.write(value.maxLng, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.minLat) +
        FfiConverterFloat64.allocationSize(value.maxLat) +
        FfiConverterFloat64.allocationSize(value.minLng) +
        FfiConverterFloat64.allocationSize(value.maxLng)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Detection stats for FFI
 */
export type FfiDetectionStats = {
  activitiesProcessed: /*u32*/ number;
  overlapsFound: /*u32*/ number;
  sectionsByScale: Map<string, /*u32*/ number>;
  potentialsByScale: Map<string, /*u32*/ number>;
};

/**
 * Generated factory for {@link FfiDetectionStats} record objects.
 */
export const FfiDetectionStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiDetectionStats, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiDetectionStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiDetectionStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiDetectionStats>,
  });
})();

const FfiConverterTypeFfiDetectionStats = (() => {
  type TypeName = FfiDetectionStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activitiesProcessed: FfiConverterUInt32.read(from),
        overlapsFound: FfiConverterUInt32.read(from),
        sectionsByScale: FfiConverterMapStringUInt32.read(from),
        potentialsByScale: FfiConverterMapStringUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.activitiesProcessed, into);
      FfiConverterUInt32.write(value.overlapsFound, into);
      FfiConverterMapStringUInt32.write(value.sectionsByScale, into);
      FfiConverterMapStringUInt32.write(value.potentialsByScale, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.activitiesProcessed) +
        FfiConverterUInt32.allocationSize(value.overlapsFound) +
        FfiConverterMapStringUInt32.allocationSize(value.sectionsByScale) +
        FfiConverterMapStringUInt32.allocationSize(value.potentialsByScale)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Direction stats for FFI.
 * Summary statistics for traversals in a single direction.
 */
export type FfiDirectionStats = {
  /**
   * Average time across all traversals in this direction (seconds)
   */
  avgTime: /*f64*/ number | undefined;
  /**
   * Unix timestamp of most recent traversal in this direction
   */
  lastActivity: /*i64*/ bigint | undefined;
  /**
   * Number of traversals in this direction
   */
  count: /*u32*/ number;
};

/**
 * Generated factory for {@link FfiDirectionStats} record objects.
 */
export const FfiDirectionStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiDirectionStats, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiDirectionStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiDirectionStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiDirectionStats>,
  });
})();

const FfiConverterTypeFfiDirectionStats = (() => {
  type TypeName = FfiDirectionStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        avgTime: FfiConverterOptionalFloat64.read(from),
        lastActivity: FfiConverterOptionalInt64.read(from),
        count: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalFloat64.write(value.avgTime, into);
      FfiConverterOptionalInt64.write(value.lastActivity, into);
      FfiConverterUInt32.write(value.count, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalFloat64.allocationSize(value.avgTime) +
        FfiConverterOptionalInt64.allocationSize(value.lastActivity) +
        FfiConverterUInt32.allocationSize(value.count)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Frequent section for FFI
 */
export type FfiFrequentSection = {
  id: string;
  name: string | undefined;
  sportType: string;
  polyline: Array<FfiGpsPoint>;
  representativeActivityId: string;
  activityIds: Array<string>;
  activityPortions: Array<FfiSectionPortion>;
  routeIds: Array<string>;
  visitCount: /*u32*/ number;
  distanceMeters: /*f64*/ number;
  confidence: /*f64*/ number;
  observationCount: /*u32*/ number;
  averageSpread: /*f64*/ number;
  pointDensity: Array</*u32*/ number>;
  scale: string | undefined;
  isUserDefined: boolean;
  stability: /*f64*/ number;
  version: /*u32*/ number;
  updatedAt: string | undefined;
  createdAt: string | undefined;
};

/**
 * Generated factory for {@link FfiFrequentSection} record objects.
 */
export const FfiFrequentSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiFrequentSection, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiFrequentSection}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiFrequentSection}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiFrequentSection>,
  });
})();

const FfiConverterTypeFfiFrequentSection = (() => {
  type TypeName = FfiFrequentSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        sportType: FfiConverterString.read(from),
        polyline: FfiConverterArrayTypeFfiGpsPoint.read(from),
        representativeActivityId: FfiConverterString.read(from),
        activityIds: FfiConverterArrayString.read(from),
        activityPortions: FfiConverterArrayTypeFfiSectionPortion.read(from),
        routeIds: FfiConverterArrayString.read(from),
        visitCount: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        confidence: FfiConverterFloat64.read(from),
        observationCount: FfiConverterUInt32.read(from),
        averageSpread: FfiConverterFloat64.read(from),
        pointDensity: FfiConverterArrayUInt32.read(from),
        scale: FfiConverterOptionalString.read(from),
        isUserDefined: FfiConverterBool.read(from),
        stability: FfiConverterFloat64.read(from),
        version: FfiConverterUInt32.read(from),
        updatedAt: FfiConverterOptionalString.read(from),
        createdAt: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterArrayTypeFfiGpsPoint.write(value.polyline, into);
      FfiConverterString.write(value.representativeActivityId, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterArrayTypeFfiSectionPortion.write(
        value.activityPortions,
        into,
      );
      FfiConverterArrayString.write(value.routeIds, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterFloat64.write(value.confidence, into);
      FfiConverterUInt32.write(value.observationCount, into);
      FfiConverterFloat64.write(value.averageSpread, into);
      FfiConverterArrayUInt32.write(value.pointDensity, into);
      FfiConverterOptionalString.write(value.scale, into);
      FfiConverterBool.write(value.isUserDefined, into);
      FfiConverterFloat64.write(value.stability, into);
      FfiConverterUInt32.write(value.version, into);
      FfiConverterOptionalString.write(value.updatedAt, into);
      FfiConverterOptionalString.write(value.createdAt, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterArrayTypeFfiGpsPoint.allocationSize(value.polyline) +
        FfiConverterString.allocationSize(value.representativeActivityId) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterArrayTypeFfiSectionPortion.allocationSize(
          value.activityPortions,
        ) +
        FfiConverterArrayString.allocationSize(value.routeIds) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterFloat64.allocationSize(value.confidence) +
        FfiConverterUInt32.allocationSize(value.observationCount) +
        FfiConverterFloat64.allocationSize(value.averageSpread) +
        FfiConverterArrayUInt32.allocationSize(value.pointDensity) +
        FfiConverterOptionalString.allocationSize(value.scale) +
        FfiConverterBool.allocationSize(value.isUserDefined) +
        FfiConverterFloat64.allocationSize(value.stability) +
        FfiConverterUInt32.allocationSize(value.version) +
        FfiConverterOptionalString.allocationSize(value.updatedAt) +
        FfiConverterOptionalString.allocationSize(value.createdAt)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * FTP trend data.
 */
export type FfiFtpTrend = {
  /**
   * Most recent FTP value
   */
  latestFtp: /*u16*/ number | undefined;
  /**
   * Date of most recent FTP (Unix timestamp seconds)
   */
  latestDate: /*i64*/ bigint | undefined;
  /**
   * Previous different FTP value
   */
  previousFtp: /*u16*/ number | undefined;
  /**
   * Date of previous FTP (Unix timestamp seconds)
   */
  previousDate: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link FfiFtpTrend} record objects.
 */
export const FfiFtpTrend = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiFtpTrend, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiFtpTrend}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiFtpTrend}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiFtpTrend>,
  });
})();

const FfiConverterTypeFfiFtpTrend = (() => {
  type TypeName = FfiFtpTrend;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        latestFtp: FfiConverterOptionalUInt16.read(from),
        latestDate: FfiConverterOptionalInt64.read(from),
        previousFtp: FfiConverterOptionalUInt16.read(from),
        previousDate: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt16.write(value.latestFtp, into);
      FfiConverterOptionalInt64.write(value.latestDate, into);
      FfiConverterOptionalUInt16.write(value.previousFtp, into);
      FfiConverterOptionalInt64.write(value.previousDate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt16.allocationSize(value.latestFtp) +
        FfiConverterOptionalInt64.allocationSize(value.latestDate) +
        FfiConverterOptionalUInt16.allocationSize(value.previousFtp) +
        FfiConverterOptionalInt64.allocationSize(value.previousDate)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * GPS point for FFI
 */
export type FfiGpsPoint = {
  latitude: /*f64*/ number;
  longitude: /*f64*/ number;
  elevation: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link FfiGpsPoint} record objects.
 */
export const FfiGpsPoint = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiGpsPoint, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiGpsPoint}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiGpsPoint}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiGpsPoint>,
  });
})();

const FfiConverterTypeFfiGpsPoint = (() => {
  type TypeName = FfiGpsPoint;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        latitude: FfiConverterFloat64.read(from),
        longitude: FfiConverterFloat64.read(from),
        elevation: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.latitude, into);
      FfiConverterFloat64.write(value.longitude, into);
      FfiConverterOptionalFloat64.write(value.elevation, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.latitude) +
        FfiConverterFloat64.allocationSize(value.longitude) +
        FfiConverterOptionalFloat64.allocationSize(value.elevation)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Group summary with embedded consensus polyline for the Routes screen.
 * Avoids N separate getConsensusRoute() calls.
 */
export type FfiGroupWithPolyline = {
  groupId: string;
  representativeId: string;
  sportType: string;
  activityCount: /*u32*/ number;
  customName: string | undefined;
  bounds: FfiBounds | undefined;
  /**
   * Distance in meters (from representative activity's metrics)
   */
  distanceMeters: /*f64*/ number;
  /**
   * Flat lat/lng pairs [lat1, lng1, lat2, lng2, ...]
   */
  consensusPolyline: Array</*f64*/ number>;
};

/**
 * Generated factory for {@link FfiGroupWithPolyline} record objects.
 */
export const FfiGroupWithPolyline = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiGroupWithPolyline,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiGroupWithPolyline}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiGroupWithPolyline}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiGroupWithPolyline>,
  });
})();

const FfiConverterTypeFfiGroupWithPolyline = (() => {
  type TypeName = FfiGroupWithPolyline;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        groupId: FfiConverterString.read(from),
        representativeId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
        activityCount: FfiConverterUInt32.read(from),
        customName: FfiConverterOptionalString.read(from),
        bounds: FfiConverterOptionalTypeFfiBounds.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        consensusPolyline: FfiConverterArrayFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.groupId, into);
      FfiConverterString.write(value.representativeId, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterOptionalString.write(value.customName, into);
      FfiConverterOptionalTypeFfiBounds.write(value.bounds, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterArrayFloat64.write(value.consensusPolyline, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.groupId) +
        FfiConverterString.allocationSize(value.representativeId) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterOptionalString.allocationSize(value.customName) +
        FfiConverterOptionalTypeFfiBounds.allocationSize(value.bounds) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterArrayFloat64.allocationSize(value.consensusPolyline)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Activity heatmap day entry.
 */
export type FfiHeatmapDay = {
  /**
   * Date string "YYYY-MM-DD"
   */
  date: string;
  /**
   * Intensity level (0-4)
   */
  intensity: /*u8*/ number;
};

/**
 * Generated factory for {@link FfiHeatmapDay} record objects.
 */
export const FfiHeatmapDay = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiHeatmapDay, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiHeatmapDay}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiHeatmapDay}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiHeatmapDay>,
  });
})();

const FfiConverterTypeFfiHeatmapDay = (() => {
  type TypeName = FfiHeatmapDay;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        date: FfiConverterString.read(from),
        intensity: FfiConverterUInt8.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.date, into);
      FfiConverterUInt8.write(value.intensity, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.date) +
        FfiConverterUInt8.allocationSize(value.intensity)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Monthly aggregate value.
 */
export type FfiMonthlyAggregate = {
  /**
   * Month (0-11)
   */
  month: /*u8*/ number;
  /**
   * Aggregated value (hours, distance in meters, or TSS)
   */
  value: /*f64*/ number;
};

/**
 * Generated factory for {@link FfiMonthlyAggregate} record objects.
 */
export const FfiMonthlyAggregate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiMonthlyAggregate, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMonthlyAggregate}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMonthlyAggregate}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiMonthlyAggregate>,
  });
})();

const FfiConverterTypeFfiMonthlyAggregate = (() => {
  type TypeName = FfiMonthlyAggregate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        month: FfiConverterUInt8.read(from),
        value: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt8.write(value.month, into);
      FfiConverterFloat64.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt8.allocationSize(value.month) +
        FfiConverterFloat64.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Multi-scale section result for FFI
 */
export type FfiMultiScaleSectionResult = {
  sections: Array<FfiFrequentSection>;
  potentials: Array<FfiPotentialSection>;
  stats: FfiDetectionStats;
};

/**
 * Generated factory for {@link FfiMultiScaleSectionResult} record objects.
 */
export const FfiMultiScaleSectionResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiMultiScaleSectionResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiMultiScaleSectionResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiMultiScaleSectionResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiMultiScaleSectionResult>,
  });
})();

const FfiConverterTypeFfiMultiScaleSectionResult = (() => {
  type TypeName = FfiMultiScaleSectionResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sections: FfiConverterArrayTypeFfiFrequentSection.read(from),
        potentials: FfiConverterArrayTypeFfiPotentialSection.read(from),
        stats: FfiConverterTypeFfiDetectionStats.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFfiFrequentSection.write(value.sections, into);
      FfiConverterArrayTypeFfiPotentialSection.write(value.potentials, into);
      FfiConverterTypeFfiDetectionStats.write(value.stats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeFfiFrequentSection.allocationSize(value.sections) +
        FfiConverterArrayTypeFfiPotentialSection.allocationSize(
          value.potentials,
        ) +
        FfiConverterTypeFfiDetectionStats.allocationSize(value.stats)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Aggregated stats for a date range.
 */
export type FfiPeriodStats = {
  /**
   * Number of activities
   */
  count: /*u32*/ number;
  /**
   * Total moving time in seconds
   */
  totalDuration: /*i64*/ bigint;
  /**
   * Total distance in meters
   */
  totalDistance: /*f64*/ number;
  /**
   * Total training load (TSS)
   */
  totalTss: /*f64*/ number;
};

/**
 * Generated factory for {@link FfiPeriodStats} record objects.
 */
export const FfiPeriodStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiPeriodStats, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiPeriodStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiPeriodStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiPeriodStats>,
  });
})();

const FfiConverterTypeFfiPeriodStats = (() => {
  type TypeName = FfiPeriodStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        count: FfiConverterUInt32.read(from),
        totalDuration: FfiConverterInt64.read(from),
        totalDistance: FfiConverterFloat64.read(from),
        totalTss: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.count, into);
      FfiConverterInt64.write(value.totalDuration, into);
      FfiConverterFloat64.write(value.totalDistance, into);
      FfiConverterFloat64.write(value.totalTss, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.count) +
        FfiConverterInt64.allocationSize(value.totalDuration) +
        FfiConverterFloat64.allocationSize(value.totalDistance) +
        FfiConverterFloat64.allocationSize(value.totalTss)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Potential section for FFI
 */
export type FfiPotentialSection = {
  id: string;
  sportType: string;
  polyline: Array<FfiGpsPoint>;
  activityIds: Array<string>;
  distanceMeters: /*f64*/ number;
  confidence: /*f64*/ number;
  scale: string;
};

/**
 * Generated factory for {@link FfiPotentialSection} record objects.
 */
export const FfiPotentialSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiPotentialSection, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiPotentialSection}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiPotentialSection}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiPotentialSection>,
  });
})();

const FfiConverterTypeFfiPotentialSection = (() => {
  type TypeName = FfiPotentialSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
        polyline: FfiConverterArrayTypeFfiGpsPoint.read(from),
        activityIds: FfiConverterArrayString.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        confidence: FfiConverterFloat64.read(from),
        scale: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterArrayTypeFfiGpsPoint.write(value.polyline, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterFloat64.write(value.confidence, into);
      FfiConverterString.write(value.scale, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterArrayTypeFfiGpsPoint.allocationSize(value.polyline) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterFloat64.allocationSize(value.confidence) +
        FfiConverterString.allocationSize(value.scale)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Route group for FFI
 */
export type FfiRouteGroup = {
  groupId: string;
  representativeId: string;
  activityIds: Array<string>;
  sportType: string;
  bounds: FfiBounds | undefined;
  customName: string | undefined;
  bestTime: /*f64*/ number | undefined;
  avgTime: /*f64*/ number | undefined;
  bestPace: /*f64*/ number | undefined;
  bestActivityId: string | undefined;
};

/**
 * Generated factory for {@link FfiRouteGroup} record objects.
 */
export const FfiRouteGroup = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiRouteGroup, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRouteGroup}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRouteGroup}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiRouteGroup>,
  });
})();

const FfiConverterTypeFfiRouteGroup = (() => {
  type TypeName = FfiRouteGroup;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        groupId: FfiConverterString.read(from),
        representativeId: FfiConverterString.read(from),
        activityIds: FfiConverterArrayString.read(from),
        sportType: FfiConverterString.read(from),
        bounds: FfiConverterOptionalTypeFfiBounds.read(from),
        customName: FfiConverterOptionalString.read(from),
        bestTime: FfiConverterOptionalFloat64.read(from),
        avgTime: FfiConverterOptionalFloat64.read(from),
        bestPace: FfiConverterOptionalFloat64.read(from),
        bestActivityId: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.groupId, into);
      FfiConverterString.write(value.representativeId, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterOptionalTypeFfiBounds.write(value.bounds, into);
      FfiConverterOptionalString.write(value.customName, into);
      FfiConverterOptionalFloat64.write(value.bestTime, into);
      FfiConverterOptionalFloat64.write(value.avgTime, into);
      FfiConverterOptionalFloat64.write(value.bestPace, into);
      FfiConverterOptionalString.write(value.bestActivityId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.groupId) +
        FfiConverterString.allocationSize(value.representativeId) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterOptionalTypeFfiBounds.allocationSize(value.bounds) +
        FfiConverterOptionalString.allocationSize(value.customName) +
        FfiConverterOptionalFloat64.allocationSize(value.bestTime) +
        FfiConverterOptionalFloat64.allocationSize(value.avgTime) +
        FfiConverterOptionalFloat64.allocationSize(value.bestPace) +
        FfiConverterOptionalString.allocationSize(value.bestActivityId)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Route performance for FFI.
 * Performance data for a single activity on a route.
 */
export type FfiRoutePerformance = {
  activityId: string;
  name: string;
  /**
   * Unix timestamp
   */
  date: /*i64*/ bigint;
  /**
   * Speed in m/s (distance / moving_time)
   */
  speed: /*f64*/ number;
  /**
   * Elapsed time in seconds
   */
  duration: /*u32*/ number;
  /**
   * Moving time in seconds
   */
  movingTime: /*u32*/ number;
  /**
   * Distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Elevation gain in meters
   */
  elevationGain: /*f64*/ number;
  /**
   * Average heart rate (optional)
   */
  avgHr: /*u16*/ number | undefined;
  /**
   * Average power in watts (optional)
   */
  avgPower: /*u16*/ number | undefined;
  /**
   * Is this the current activity being viewed
   */
  isCurrent: boolean;
  /**
   * Match direction: "same", "reverse", or "partial"
   */
  direction: string;
  /**
   * Match percentage (0-100), None if no match data available
   */
  matchPercentage: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link FfiRoutePerformance} record objects.
 */
export const FfiRoutePerformance = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiRoutePerformance, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRoutePerformance}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRoutePerformance}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiRoutePerformance>,
  });
})();

const FfiConverterTypeFfiRoutePerformance = (() => {
  type TypeName = FfiRoutePerformance;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        date: FfiConverterInt64.read(from),
        speed: FfiConverterFloat64.read(from),
        duration: FfiConverterUInt32.read(from),
        movingTime: FfiConverterUInt32.read(from),
        distance: FfiConverterFloat64.read(from),
        elevationGain: FfiConverterFloat64.read(from),
        avgHr: FfiConverterOptionalUInt16.read(from),
        avgPower: FfiConverterOptionalUInt16.read(from),
        isCurrent: FfiConverterBool.read(from),
        direction: FfiConverterString.read(from),
        matchPercentage: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.name, into);
      FfiConverterInt64.write(value.date, into);
      FfiConverterFloat64.write(value.speed, into);
      FfiConverterUInt32.write(value.duration, into);
      FfiConverterUInt32.write(value.movingTime, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterFloat64.write(value.elevationGain, into);
      FfiConverterOptionalUInt16.write(value.avgHr, into);
      FfiConverterOptionalUInt16.write(value.avgPower, into);
      FfiConverterBool.write(value.isCurrent, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterOptionalFloat64.write(value.matchPercentage, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterInt64.allocationSize(value.date) +
        FfiConverterFloat64.allocationSize(value.speed) +
        FfiConverterUInt32.allocationSize(value.duration) +
        FfiConverterUInt32.allocationSize(value.movingTime) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterFloat64.allocationSize(value.elevationGain) +
        FfiConverterOptionalUInt16.allocationSize(value.avgHr) +
        FfiConverterOptionalUInt16.allocationSize(value.avgPower) +
        FfiConverterBool.allocationSize(value.isCurrent) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterOptionalFloat64.allocationSize(value.matchPercentage)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Route performance result for FFI.
 * Complete performance data for a route group across all activities.
 * Replaces the JSON-returning `persistent_engine_get_route_performances_json()`.
 */
export type FfiRoutePerformanceResult = {
  /**
   * Performances sorted by date (oldest first)
   */
  performances: Array<FfiRoutePerformance>;
  /**
   * Best performance (fastest speed) - overall regardless of direction
   */
  best: FfiRoutePerformance | undefined;
  /**
   * Best performance in forward/same direction
   */
  bestForward: FfiRoutePerformance | undefined;
  /**
   * Best performance in reverse direction
   */
  bestReverse: FfiRoutePerformance | undefined;
  /**
   * Summary stats for forward/same direction
   */
  forwardStats: FfiDirectionStats | undefined;
  /**
   * Summary stats for reverse direction
   */
  reverseStats: FfiDirectionStats | undefined;
  /**
   * Current activity's rank (1 = fastest), if current_activity_id was provided
   */
  currentRank: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link FfiRoutePerformanceResult} record objects.
 */
export const FfiRoutePerformanceResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiRoutePerformanceResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRoutePerformanceResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRoutePerformanceResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiRoutePerformanceResult>,
  });
})();

const FfiConverterTypeFfiRoutePerformanceResult = (() => {
  type TypeName = FfiRoutePerformanceResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        performances: FfiConverterArrayTypeFfiRoutePerformance.read(from),
        best: FfiConverterOptionalTypeFfiRoutePerformance.read(from),
        bestForward: FfiConverterOptionalTypeFfiRoutePerformance.read(from),
        bestReverse: FfiConverterOptionalTypeFfiRoutePerformance.read(from),
        forwardStats: FfiConverterOptionalTypeFfiDirectionStats.read(from),
        reverseStats: FfiConverterOptionalTypeFfiDirectionStats.read(from),
        currentRank: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFfiRoutePerformance.write(value.performances, into);
      FfiConverterOptionalTypeFfiRoutePerformance.write(value.best, into);
      FfiConverterOptionalTypeFfiRoutePerformance.write(
        value.bestForward,
        into,
      );
      FfiConverterOptionalTypeFfiRoutePerformance.write(
        value.bestReverse,
        into,
      );
      FfiConverterOptionalTypeFfiDirectionStats.write(value.forwardStats, into);
      FfiConverterOptionalTypeFfiDirectionStats.write(value.reverseStats, into);
      FfiConverterOptionalUInt32.write(value.currentRank, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeFfiRoutePerformance.allocationSize(
          value.performances,
        ) +
        FfiConverterOptionalTypeFfiRoutePerformance.allocationSize(value.best) +
        FfiConverterOptionalTypeFfiRoutePerformance.allocationSize(
          value.bestForward,
        ) +
        FfiConverterOptionalTypeFfiRoutePerformance.allocationSize(
          value.bestReverse,
        ) +
        FfiConverterOptionalTypeFfiDirectionStats.allocationSize(
          value.forwardStats,
        ) +
        FfiConverterOptionalTypeFfiDirectionStats.allocationSize(
          value.reverseStats,
        ) +
        FfiConverterOptionalUInt32.allocationSize(value.currentRank)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Route signature for FFI
 */
export type FfiRouteSignature = {
  activityId: string;
  points: Array<FfiGpsPoint>;
  totalDistance: /*f64*/ number;
  startPoint: FfiGpsPoint;
  endPoint: FfiGpsPoint;
  bounds: FfiBounds;
  center: FfiGpsPoint;
};

/**
 * Generated factory for {@link FfiRouteSignature} record objects.
 */
export const FfiRouteSignature = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiRouteSignature, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRouteSignature}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRouteSignature}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiRouteSignature>,
  });
})();

const FfiConverterTypeFfiRouteSignature = (() => {
  type TypeName = FfiRouteSignature;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        points: FfiConverterArrayTypeFfiGpsPoint.read(from),
        totalDistance: FfiConverterFloat64.read(from),
        startPoint: FfiConverterTypeFfiGpsPoint.read(from),
        endPoint: FfiConverterTypeFfiGpsPoint.read(from),
        bounds: FfiConverterTypeFfiBounds.read(from),
        center: FfiConverterTypeFfiGpsPoint.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterArrayTypeFfiGpsPoint.write(value.points, into);
      FfiConverterFloat64.write(value.totalDistance, into);
      FfiConverterTypeFfiGpsPoint.write(value.startPoint, into);
      FfiConverterTypeFfiGpsPoint.write(value.endPoint, into);
      FfiConverterTypeFfiBounds.write(value.bounds, into);
      FfiConverterTypeFfiGpsPoint.write(value.center, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterArrayTypeFfiGpsPoint.allocationSize(value.points) +
        FfiConverterFloat64.allocationSize(value.totalDistance) +
        FfiConverterTypeFfiGpsPoint.allocationSize(value.startPoint) +
        FfiConverterTypeFfiGpsPoint.allocationSize(value.endPoint) +
        FfiConverterTypeFfiBounds.allocationSize(value.bounds) +
        FfiConverterTypeFfiGpsPoint.allocationSize(value.center)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * All data needed by the Routes screen in a single FFI call.
 * Supports pagination via limit/offset for groups and sections.
 */
export type FfiRoutesScreenData = {
  activityCount: /*u32*/ number;
  groupCount: /*u32*/ number;
  sectionCount: /*u32*/ number;
  oldestDate: /*i64*/ bigint | undefined;
  newestDate: /*i64*/ bigint | undefined;
  groups: Array<FfiGroupWithPolyline>;
  sections: Array<FfiSectionWithPolyline>;
  /**
   * Whether more groups are available beyond the current page
   */
  hasMoreGroups: boolean;
  /**
   * Whether more sections are available beyond the current page
   */
  hasMoreSections: boolean;
};

/**
 * Generated factory for {@link FfiRoutesScreenData} record objects.
 */
export const FfiRoutesScreenData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiRoutesScreenData, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiRoutesScreenData}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiRoutesScreenData}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiRoutesScreenData>,
  });
})();

const FfiConverterTypeFfiRoutesScreenData = (() => {
  type TypeName = FfiRoutesScreenData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityCount: FfiConverterUInt32.read(from),
        groupCount: FfiConverterUInt32.read(from),
        sectionCount: FfiConverterUInt32.read(from),
        oldestDate: FfiConverterOptionalInt64.read(from),
        newestDate: FfiConverterOptionalInt64.read(from),
        groups: FfiConverterArrayTypeFfiGroupWithPolyline.read(from),
        sections: FfiConverterArrayTypeFfiSectionWithPolyline.read(from),
        hasMoreGroups: FfiConverterBool.read(from),
        hasMoreSections: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterUInt32.write(value.groupCount, into);
      FfiConverterUInt32.write(value.sectionCount, into);
      FfiConverterOptionalInt64.write(value.oldestDate, into);
      FfiConverterOptionalInt64.write(value.newestDate, into);
      FfiConverterArrayTypeFfiGroupWithPolyline.write(value.groups, into);
      FfiConverterArrayTypeFfiSectionWithPolyline.write(value.sections, into);
      FfiConverterBool.write(value.hasMoreGroups, into);
      FfiConverterBool.write(value.hasMoreSections, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterUInt32.allocationSize(value.groupCount) +
        FfiConverterUInt32.allocationSize(value.sectionCount) +
        FfiConverterOptionalInt64.allocationSize(value.oldestDate) +
        FfiConverterOptionalInt64.allocationSize(value.newestDate) +
        FfiConverterArrayTypeFfiGroupWithPolyline.allocationSize(value.groups) +
        FfiConverterArrayTypeFfiSectionWithPolyline.allocationSize(
          value.sections,
        ) +
        FfiConverterBool.allocationSize(value.hasMoreGroups) +
        FfiConverterBool.allocationSize(value.hasMoreSections)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Scale preset for FFI
 */
export type FfiScalePreset = {
  name: string;
  minLength: /*f64*/ number;
  maxLength: /*f64*/ number;
  minActivities: /*u32*/ number;
};

/**
 * Generated factory for {@link FfiScalePreset} record objects.
 */
export const FfiScalePreset = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiScalePreset, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiScalePreset}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiScalePreset}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiScalePreset>,
  });
})();

const FfiConverterTypeFfiScalePreset = (() => {
  type TypeName = FfiScalePreset;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        minLength: FfiConverterFloat64.read(from),
        maxLength: FfiConverterFloat64.read(from),
        minActivities: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterFloat64.write(value.minLength, into);
      FfiConverterFloat64.write(value.maxLength, into);
      FfiConverterUInt32.write(value.minActivities, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterFloat64.allocationSize(value.minLength) +
        FfiConverterFloat64.allocationSize(value.maxLength) +
        FfiConverterUInt32.allocationSize(value.minActivities)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Unified section for FFI.
 * Represents both auto-detected and custom sections with the same structure.
 */
export type FfiSection = {
  id: string;
  sectionType: string;
  name: string | undefined;
  sportType: string;
  polyline: Array<FfiGpsPoint>;
  distanceMeters: /*f64*/ number;
  representativeActivityId: string | undefined;
  activityIds: Array<string>;
  visitCount: /*u32*/ number;
  confidence: /*f64*/ number | undefined;
  observationCount: /*u32*/ number | undefined;
  averageSpread: /*f64*/ number | undefined;
  pointDensity: Array</*u32*/ number> | undefined;
  scale: string | undefined;
  isUserDefined: boolean;
  stability: /*f64*/ number | undefined;
  version: /*u32*/ number | undefined;
  updatedAt: string | undefined;
  createdAt: string;
  routeIds: Array<string> | undefined;
  sourceActivityId: string | undefined;
  startIndex: /*u32*/ number | undefined;
  endIndex: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link FfiSection} record objects.
 */
export const FfiSection = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiSection, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSection}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSection}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiSection>,
  });
})();

const FfiConverterTypeFfiSection = (() => {
  type TypeName = FfiSection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        sectionType: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        sportType: FfiConverterString.read(from),
        polyline: FfiConverterArrayTypeFfiGpsPoint.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        representativeActivityId: FfiConverterOptionalString.read(from),
        activityIds: FfiConverterArrayString.read(from),
        visitCount: FfiConverterUInt32.read(from),
        confidence: FfiConverterOptionalFloat64.read(from),
        observationCount: FfiConverterOptionalUInt32.read(from),
        averageSpread: FfiConverterOptionalFloat64.read(from),
        pointDensity: FfiConverterOptionalArrayUInt32.read(from),
        scale: FfiConverterOptionalString.read(from),
        isUserDefined: FfiConverterBool.read(from),
        stability: FfiConverterOptionalFloat64.read(from),
        version: FfiConverterOptionalUInt32.read(from),
        updatedAt: FfiConverterOptionalString.read(from),
        createdAt: FfiConverterString.read(from),
        routeIds: FfiConverterOptionalArrayString.read(from),
        sourceActivityId: FfiConverterOptionalString.read(from),
        startIndex: FfiConverterOptionalUInt32.read(from),
        endIndex: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.sectionType, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterArrayTypeFfiGpsPoint.write(value.polyline, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterOptionalString.write(value.representativeActivityId, into);
      FfiConverterArrayString.write(value.activityIds, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterOptionalFloat64.write(value.confidence, into);
      FfiConverterOptionalUInt32.write(value.observationCount, into);
      FfiConverterOptionalFloat64.write(value.averageSpread, into);
      FfiConverterOptionalArrayUInt32.write(value.pointDensity, into);
      FfiConverterOptionalString.write(value.scale, into);
      FfiConverterBool.write(value.isUserDefined, into);
      FfiConverterOptionalFloat64.write(value.stability, into);
      FfiConverterOptionalUInt32.write(value.version, into);
      FfiConverterOptionalString.write(value.updatedAt, into);
      FfiConverterString.write(value.createdAt, into);
      FfiConverterOptionalArrayString.write(value.routeIds, into);
      FfiConverterOptionalString.write(value.sourceActivityId, into);
      FfiConverterOptionalUInt32.write(value.startIndex, into);
      FfiConverterOptionalUInt32.write(value.endIndex, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.sectionType) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterArrayTypeFfiGpsPoint.allocationSize(value.polyline) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterOptionalString.allocationSize(
          value.representativeActivityId,
        ) +
        FfiConverterArrayString.allocationSize(value.activityIds) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterOptionalFloat64.allocationSize(value.confidence) +
        FfiConverterOptionalUInt32.allocationSize(value.observationCount) +
        FfiConverterOptionalFloat64.allocationSize(value.averageSpread) +
        FfiConverterOptionalArrayUInt32.allocationSize(value.pointDensity) +
        FfiConverterOptionalString.allocationSize(value.scale) +
        FfiConverterBool.allocationSize(value.isUserDefined) +
        FfiConverterOptionalFloat64.allocationSize(value.stability) +
        FfiConverterOptionalUInt32.allocationSize(value.version) +
        FfiConverterOptionalString.allocationSize(value.updatedAt) +
        FfiConverterString.allocationSize(value.createdAt) +
        FfiConverterOptionalArrayString.allocationSize(value.routeIds) +
        FfiConverterOptionalString.allocationSize(value.sourceActivityId) +
        FfiConverterOptionalUInt32.allocationSize(value.startIndex) +
        FfiConverterOptionalUInt32.allocationSize(value.endIndex)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section config for FFI
 */
export type FfiSectionConfig = {
  proximityThreshold: /*f64*/ number;
  minSectionLength: /*f64*/ number;
  maxSectionLength: /*f64*/ number;
  minActivities: /*u32*/ number;
  clusterTolerance: /*f64*/ number;
  samplePoints: /*u32*/ number;
  detectionMode: string;
  includePotentials: boolean;
  scalePresets: Array<FfiScalePreset>;
  preserveHierarchy: boolean;
};

/**
 * Generated factory for {@link FfiSectionConfig} record objects.
 */
export const FfiSectionConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiSectionConfig, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSectionConfig}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSectionConfig}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiSectionConfig>,
  });
})();

const FfiConverterTypeFfiSectionConfig = (() => {
  type TypeName = FfiSectionConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        proximityThreshold: FfiConverterFloat64.read(from),
        minSectionLength: FfiConverterFloat64.read(from),
        maxSectionLength: FfiConverterFloat64.read(from),
        minActivities: FfiConverterUInt32.read(from),
        clusterTolerance: FfiConverterFloat64.read(from),
        samplePoints: FfiConverterUInt32.read(from),
        detectionMode: FfiConverterString.read(from),
        includePotentials: FfiConverterBool.read(from),
        scalePresets: FfiConverterArrayTypeFfiScalePreset.read(from),
        preserveHierarchy: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.proximityThreshold, into);
      FfiConverterFloat64.write(value.minSectionLength, into);
      FfiConverterFloat64.write(value.maxSectionLength, into);
      FfiConverterUInt32.write(value.minActivities, into);
      FfiConverterFloat64.write(value.clusterTolerance, into);
      FfiConverterUInt32.write(value.samplePoints, into);
      FfiConverterString.write(value.detectionMode, into);
      FfiConverterBool.write(value.includePotentials, into);
      FfiConverterArrayTypeFfiScalePreset.write(value.scalePresets, into);
      FfiConverterBool.write(value.preserveHierarchy, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.proximityThreshold) +
        FfiConverterFloat64.allocationSize(value.minSectionLength) +
        FfiConverterFloat64.allocationSize(value.maxSectionLength) +
        FfiConverterUInt32.allocationSize(value.minActivities) +
        FfiConverterFloat64.allocationSize(value.clusterTolerance) +
        FfiConverterUInt32.allocationSize(value.samplePoints) +
        FfiConverterString.allocationSize(value.detectionMode) +
        FfiConverterBool.allocationSize(value.includePotentials) +
        FfiConverterArrayTypeFfiScalePreset.allocationSize(value.scalePresets) +
        FfiConverterBool.allocationSize(value.preserveHierarchy)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section lap for FFI.
 * Represents a single traversal of a section within an activity.
 */
export type FfiSectionLap = {
  id: string;
  activityId: string;
  /**
   * Lap time in seconds
   */
  time: /*f64*/ number;
  /**
   * Pace in m/s
   */
  pace: /*f64*/ number;
  /**
   * Distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Direction: "forward" or "backward"
   */
  direction: string;
  /**
   * Start index in the activity's GPS track
   */
  startIndex: /*u32*/ number;
  /**
   * End index in the activity's GPS track
   */
  endIndex: /*u32*/ number;
};

/**
 * Generated factory for {@link FfiSectionLap} record objects.
 */
export const FfiSectionLap = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiSectionLap, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSectionLap}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSectionLap}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiSectionLap>,
  });
})();

const FfiConverterTypeFfiSectionLap = (() => {
  type TypeName = FfiSectionLap;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        activityId: FfiConverterString.read(from),
        time: FfiConverterFloat64.read(from),
        pace: FfiConverterFloat64.read(from),
        distance: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.activityId, into);
      FfiConverterFloat64.write(value.time, into);
      FfiConverterFloat64.write(value.pace, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterFloat64.allocationSize(value.time) +
        FfiConverterFloat64.allocationSize(value.pace) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section performance record for FFI.
 * Contains all traversals for a single activity on a section.
 */
export type FfiSectionPerformanceRecord = {
  activityId: string;
  activityName: string;
  /**
   * Unix timestamp
   */
  activityDate: /*i64*/ bigint;
  /**
   * All laps for this activity on this section
   */
  laps: Array<FfiSectionLap>;
  /**
   * Number of times this section was traversed
   */
  lapCount: /*u32*/ number;
  /**
   * Best (fastest) lap time in seconds
   */
  bestTime: /*f64*/ number;
  /**
   * Best pace in m/s
   */
  bestPace: /*f64*/ number;
  /**
   * Average lap time in seconds
   */
  avgTime: /*f64*/ number;
  /**
   * Average pace in m/s
   */
  avgPace: /*f64*/ number;
  /**
   * Primary direction: "forward" or "backward"
   */
  direction: string;
  /**
   * Section distance in meters
   */
  sectionDistance: /*f64*/ number;
};

/**
 * Generated factory for {@link FfiSectionPerformanceRecord} record objects.
 */
export const FfiSectionPerformanceRecord = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiSectionPerformanceRecord,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSectionPerformanceRecord}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSectionPerformanceRecord}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiSectionPerformanceRecord>,
  });
})();

const FfiConverterTypeFfiSectionPerformanceRecord = (() => {
  type TypeName = FfiSectionPerformanceRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        activityName: FfiConverterString.read(from),
        activityDate: FfiConverterInt64.read(from),
        laps: FfiConverterArrayTypeFfiSectionLap.read(from),
        lapCount: FfiConverterUInt32.read(from),
        bestTime: FfiConverterFloat64.read(from),
        bestPace: FfiConverterFloat64.read(from),
        avgTime: FfiConverterFloat64.read(from),
        avgPace: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
        sectionDistance: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.activityName, into);
      FfiConverterInt64.write(value.activityDate, into);
      FfiConverterArrayTypeFfiSectionLap.write(value.laps, into);
      FfiConverterUInt32.write(value.lapCount, into);
      FfiConverterFloat64.write(value.bestTime, into);
      FfiConverterFloat64.write(value.bestPace, into);
      FfiConverterFloat64.write(value.avgTime, into);
      FfiConverterFloat64.write(value.avgPace, into);
      FfiConverterString.write(value.direction, into);
      FfiConverterFloat64.write(value.sectionDistance, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.activityName) +
        FfiConverterInt64.allocationSize(value.activityDate) +
        FfiConverterArrayTypeFfiSectionLap.allocationSize(value.laps) +
        FfiConverterUInt32.allocationSize(value.lapCount) +
        FfiConverterFloat64.allocationSize(value.bestTime) +
        FfiConverterFloat64.allocationSize(value.bestPace) +
        FfiConverterFloat64.allocationSize(value.avgTime) +
        FfiConverterFloat64.allocationSize(value.avgPace) +
        FfiConverterString.allocationSize(value.direction) +
        FfiConverterFloat64.allocationSize(value.sectionDistance)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section performance result for FFI.
 * Complete performance data for a section across all activities.
 * Replaces the JSON-returning `persistent_engine_get_section_performances_json()`.
 */
export type FfiSectionPerformanceResult = {
  /**
   * Performance records sorted by date (oldest first)
   */
  records: Array<FfiSectionPerformanceRecord>;
  /**
   * Best record (fastest time) - overall regardless of direction
   */
  bestRecord: FfiSectionPerformanceRecord | undefined;
  /**
   * Best record in forward/same direction
   */
  bestForwardRecord: FfiSectionPerformanceRecord | undefined;
  /**
   * Best record in reverse direction
   */
  bestReverseRecord: FfiSectionPerformanceRecord | undefined;
  /**
   * Summary stats for forward/same direction
   */
  forwardStats: FfiDirectionStats | undefined;
  /**
   * Summary stats for reverse direction
   */
  reverseStats: FfiDirectionStats | undefined;
};

/**
 * Generated factory for {@link FfiSectionPerformanceResult} record objects.
 */
export const FfiSectionPerformanceResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiSectionPerformanceResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSectionPerformanceResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSectionPerformanceResult}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiSectionPerformanceResult>,
  });
})();

const FfiConverterTypeFfiSectionPerformanceResult = (() => {
  type TypeName = FfiSectionPerformanceResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        records: FfiConverterArrayTypeFfiSectionPerformanceRecord.read(from),
        bestRecord:
          FfiConverterOptionalTypeFfiSectionPerformanceRecord.read(from),
        bestForwardRecord:
          FfiConverterOptionalTypeFfiSectionPerformanceRecord.read(from),
        bestReverseRecord:
          FfiConverterOptionalTypeFfiSectionPerformanceRecord.read(from),
        forwardStats: FfiConverterOptionalTypeFfiDirectionStats.read(from),
        reverseStats: FfiConverterOptionalTypeFfiDirectionStats.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFfiSectionPerformanceRecord.write(
        value.records,
        into,
      );
      FfiConverterOptionalTypeFfiSectionPerformanceRecord.write(
        value.bestRecord,
        into,
      );
      FfiConverterOptionalTypeFfiSectionPerformanceRecord.write(
        value.bestForwardRecord,
        into,
      );
      FfiConverterOptionalTypeFfiSectionPerformanceRecord.write(
        value.bestReverseRecord,
        into,
      );
      FfiConverterOptionalTypeFfiDirectionStats.write(value.forwardStats, into);
      FfiConverterOptionalTypeFfiDirectionStats.write(value.reverseStats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeFfiSectionPerformanceRecord.allocationSize(
          value.records,
        ) +
        FfiConverterOptionalTypeFfiSectionPerformanceRecord.allocationSize(
          value.bestRecord,
        ) +
        FfiConverterOptionalTypeFfiSectionPerformanceRecord.allocationSize(
          value.bestForwardRecord,
        ) +
        FfiConverterOptionalTypeFfiSectionPerformanceRecord.allocationSize(
          value.bestReverseRecord,
        ) +
        FfiConverterOptionalTypeFfiDirectionStats.allocationSize(
          value.forwardStats,
        ) +
        FfiConverterOptionalTypeFfiDirectionStats.allocationSize(
          value.reverseStats,
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section portion for FFI
 */
export type FfiSectionPortion = {
  activityId: string;
  startIndex: /*u32*/ number;
  endIndex: /*u32*/ number;
  distanceMeters: /*f64*/ number;
  direction: string;
};

/**
 * Generated factory for {@link FfiSectionPortion} record objects.
 */
export const FfiSectionPortion = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FfiSectionPortion, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSectionPortion}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSectionPortion}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FfiSectionPortion>,
  });
})();

const FfiConverterTypeFfiSectionPortion = (() => {
  type TypeName = FfiSectionPortion;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        startIndex: FfiConverterUInt32.read(from),
        endIndex: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        direction: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterUInt32.write(value.startIndex, into);
      FfiConverterUInt32.write(value.endIndex, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterString.write(value.direction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterUInt32.allocationSize(value.startIndex) +
        FfiConverterUInt32.allocationSize(value.endIndex) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterString.allocationSize(value.direction)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Section summary with embedded polyline for the Routes screen.
 * Avoids N separate getSectionPolyline() calls.
 */
export type FfiSectionWithPolyline = {
  id: string;
  name: string | undefined;
  sportType: string;
  visitCount: /*u32*/ number;
  distanceMeters: /*f64*/ number;
  activityCount: /*u32*/ number;
  confidence: /*f64*/ number;
  scale: string | undefined;
  bounds: FfiBounds | undefined;
  /**
   * Flat lat/lng pairs [lat1, lng1, lat2, lng2, ...]
   */
  polyline: Array</*f64*/ number>;
};

/**
 * Generated factory for {@link FfiSectionWithPolyline} record objects.
 */
export const FfiSectionWithPolyline = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FfiSectionWithPolyline,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FfiSectionWithPolyline}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FfiSectionWithPolyline}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FfiSectionWithPolyline>,
  });
})();

const FfiConverterTypeFfiSectionWithPolyline = (() => {
  type TypeName = FfiSectionWithPolyline;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        sportType: FfiConverterString.read(from),
        visitCount: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        activityCount: FfiConverterUInt32.read(from),
        confidence: FfiConverterFloat64.read(from),
        scale: FfiConverterOptionalString.read(from),
        bounds: FfiConverterOptionalTypeFfiBounds.read(from),
        polyline: FfiConverterArrayFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterFloat64.write(value.confidence, into);
      FfiConverterOptionalString.write(value.scale, into);
      FfiConverterOptionalTypeFfiBounds.write(value.bounds, into);
      FfiConverterArrayFloat64.write(value.polyline, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterFloat64.allocationSize(value.confidence) +
        FfiConverterOptionalString.allocationSize(value.scale) +
        FfiConverterOptionalTypeFfiBounds.allocationSize(value.bounds) +
        FfiConverterArrayFloat64.allocationSize(value.polyline)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Lightweight group metadata for list views.
 * Used to avoid loading full group data with activity ID arrays when only summary info is needed.
 */
export type GroupSummary = {
  /**
   * Unique group ID
   */
  groupId: string;
  /**
   * Representative activity ID
   */
  representativeId: string;
  /**
   * Sport type ("Run", "Ride", etc.)
   */
  sportType: string;
  /**
   * Number of activities in this group
   */
  activityCount: /*u32*/ number;
  /**
   * Custom name (user-defined, None if not set)
   */
  customName: string | undefined;
  /**
   * Bounding box for map display
   */
  bounds: FfiBounds | undefined;
};

/**
 * Generated factory for {@link GroupSummary} record objects.
 */
export const GroupSummary = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GroupSummary, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GroupSummary}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GroupSummary}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GroupSummary>,
  });
})();

const FfiConverterTypeGroupSummary = (() => {
  type TypeName = GroupSummary;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        groupId: FfiConverterString.read(from),
        representativeId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
        activityCount: FfiConverterUInt32.read(from),
        customName: FfiConverterOptionalString.read(from),
        bounds: FfiConverterOptionalTypeFfiBounds.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.groupId, into);
      FfiConverterString.write(value.representativeId, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterOptionalString.write(value.customName, into);
      FfiConverterOptionalTypeFfiBounds.write(value.bounds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.groupId) +
        FfiConverterString.allocationSize(value.representativeId) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterOptionalString.allocationSize(value.customName) +
        FfiConverterOptionalTypeFfiBounds.allocationSize(value.bounds)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Complete activity data for map display.
 * Contains both spatial bounds and metadata for filtering and display.
 */
export type MapActivityComplete = {
  /**
   * Activity ID
   */
  activityId: string;
  /**
   * Sport type ("Run", "Ride", etc.)
   */
  sportType: string;
  /**
   * Bounding box for map display
   */
  bounds: FfiBounds;
  /**
   * Start date as Unix timestamp (seconds since epoch)
   */
  date: /*i64*/ bigint;
  /**
   * Activity name
   */
  name: string;
  /**
   * Total distance in meters
   */
  distance: /*f64*/ number;
  /**
   * Total duration in seconds (moving time)
   */
  duration: /*u32*/ number;
};

/**
 * Generated factory for {@link MapActivityComplete} record objects.
 */
export const MapActivityComplete = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MapActivityComplete, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MapActivityComplete}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MapActivityComplete}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MapActivityComplete>,
  });
})();

const FfiConverterTypeMapActivityComplete = (() => {
  type TypeName = MapActivityComplete;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
        bounds: FfiConverterTypeFfiBounds.read(from),
        date: FfiConverterInt64.read(from),
        name: FfiConverterString.read(from),
        distance: FfiConverterFloat64.read(from),
        duration: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterTypeFfiBounds.write(value.bounds, into);
      FfiConverterInt64.write(value.date, into);
      FfiConverterString.write(value.name, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterUInt32.write(value.duration, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterTypeFfiBounds.allocationSize(value.bounds) +
        FfiConverterInt64.allocationSize(value.date) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterUInt32.allocationSize(value.duration)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Lightweight activity data for map display within a viewport.
 * Returns only the fields needed for rendering: id, sport_type, bounds.
 */
export type MapActivityData = {
  activityId: string;
  sportType: string;
  bounds: FfiBounds;
};

/**
 * Generated factory for {@link MapActivityData} record objects.
 */
export const MapActivityData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MapActivityData, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MapActivityData}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MapActivityData}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MapActivityData>,
  });
})();

const FfiConverterTypeMapActivityData = (() => {
  type TypeName = MapActivityData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityId: FfiConverterString.read(from),
        sportType: FfiConverterString.read(from),
        bounds: FfiConverterTypeFfiBounds.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.activityId, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterTypeFfiBounds.write(value.bounds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.activityId) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterTypeFfiBounds.allocationSize(value.bounds)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Statistics for the persistent engine.
 */
export type PersistentEngineStats = {
  activityCount: /*u32*/ number;
  signatureCacheSize: /*u32*/ number;
  consensusCacheSize: /*u32*/ number;
  groupCount: /*u32*/ number;
  sectionCount: /*u32*/ number;
  groupsDirty: boolean;
  sectionsDirty: boolean;
  gpsTrackCount: /*u32*/ number;
  /**
   * Oldest activity date (Unix timestamp in seconds), or None if no activities
   */
  oldestDate: /*i64*/ bigint | undefined;
  /**
   * Newest activity date (Unix timestamp in seconds), or None if no activities
   */
  newestDate: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link PersistentEngineStats} record objects.
 */
export const PersistentEngineStats = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PersistentEngineStats,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PersistentEngineStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PersistentEngineStats}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PersistentEngineStats>,
  });
})();

const FfiConverterTypePersistentEngineStats = (() => {
  type TypeName = PersistentEngineStats;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        activityCount: FfiConverterUInt32.read(from),
        signatureCacheSize: FfiConverterUInt32.read(from),
        consensusCacheSize: FfiConverterUInt32.read(from),
        groupCount: FfiConverterUInt32.read(from),
        sectionCount: FfiConverterUInt32.read(from),
        groupsDirty: FfiConverterBool.read(from),
        sectionsDirty: FfiConverterBool.read(from),
        gpsTrackCount: FfiConverterUInt32.read(from),
        oldestDate: FfiConverterOptionalInt64.read(from),
        newestDate: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterUInt32.write(value.signatureCacheSize, into);
      FfiConverterUInt32.write(value.consensusCacheSize, into);
      FfiConverterUInt32.write(value.groupCount, into);
      FfiConverterUInt32.write(value.sectionCount, into);
      FfiConverterBool.write(value.groupsDirty, into);
      FfiConverterBool.write(value.sectionsDirty, into);
      FfiConverterUInt32.write(value.gpsTrackCount, into);
      FfiConverterOptionalInt64.write(value.oldestDate, into);
      FfiConverterOptionalInt64.write(value.newestDate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterUInt32.allocationSize(value.signatureCacheSize) +
        FfiConverterUInt32.allocationSize(value.consensusCacheSize) +
        FfiConverterUInt32.allocationSize(value.groupCount) +
        FfiConverterUInt32.allocationSize(value.sectionCount) +
        FfiConverterBool.allocationSize(value.groupsDirty) +
        FfiConverterBool.allocationSize(value.sectionsDirty) +
        FfiConverterUInt32.allocationSize(value.gpsTrackCount) +
        FfiConverterOptionalInt64.allocationSize(value.oldestDate) +
        FfiConverterOptionalInt64.allocationSize(value.newestDate)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Lightweight section metadata for list views (no polyline data).
 * Used to avoid loading full section data with polylines when only summary info is needed.
 */
export type SectionSummary = {
  /**
   * Unique section ID
   */
  id: string;
  /**
   * Custom name (user-defined, None if not set)
   */
  name: string | undefined;
  /**
   * Sport type ("Run", "Ride", etc.)
   */
  sportType: string;
  /**
   * Number of times this section was visited
   */
  visitCount: /*u32*/ number;
  /**
   * Section length in meters
   */
  distanceMeters: /*f64*/ number;
  /**
   * Number of activities that traverse this section
   */
  activityCount: /*u32*/ number;
  /**
   * Confidence score (0.0-1.0)
   */
  confidence: /*f64*/ number;
  /**
   * Detection scale (e.g., "neighborhood", "city")
   */
  scale: string | undefined;
  /**
   * Bounding box for map display
   */
  bounds: FfiBounds | undefined;
};

/**
 * Generated factory for {@link SectionSummary} record objects.
 */
export const SectionSummary = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SectionSummary, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SectionSummary}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SectionSummary}, with defaults specified
     * in Rust, in the {@link veloqrs} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link veloqrs} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SectionSummary>,
  });
})();

const FfiConverterTypeSectionSummary = (() => {
  type TypeName = SectionSummary;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        sportType: FfiConverterString.read(from),
        visitCount: FfiConverterUInt32.read(from),
        distanceMeters: FfiConverterFloat64.read(from),
        activityCount: FfiConverterUInt32.read(from),
        confidence: FfiConverterFloat64.read(from),
        scale: FfiConverterOptionalString.read(from),
        bounds: FfiConverterOptionalTypeFfiBounds.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterString.write(value.sportType, into);
      FfiConverterUInt32.write(value.visitCount, into);
      FfiConverterFloat64.write(value.distanceMeters, into);
      FfiConverterUInt32.write(value.activityCount, into);
      FfiConverterFloat64.write(value.confidence, into);
      FfiConverterOptionalString.write(value.scale, into);
      FfiConverterOptionalTypeFfiBounds.write(value.bounds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.sportType) +
        FfiConverterUInt32.allocationSize(value.visitCount) +
        FfiConverterFloat64.allocationSize(value.distanceMeters) +
        FfiConverterUInt32.allocationSize(value.activityCount) +
        FfiConverterFloat64.allocationSize(value.confidence) +
        FfiConverterOptionalString.allocationSize(value.scale) +
        FfiConverterOptionalTypeFfiBounds.allocationSize(value.bounds)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status,
      ),
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status,
      ),
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status,
      ),
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString,
);

// FfiConverter for Map<string, /*u32*/number>
const FfiConverterMapStringUInt32 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterUInt32,
);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64,
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for FetchAndStoreResult | undefined
const FfiConverterOptionalTypeFetchAndStoreResult = new FfiConverterOptional(
  FfiConverterTypeFetchAndStoreResult,
);

// FfiConverter for FfiBounds | undefined
const FfiConverterOptionalTypeFfiBounds = new FfiConverterOptional(
  FfiConverterTypeFfiBounds,
);

// FfiConverter for FfiDirectionStats | undefined
const FfiConverterOptionalTypeFfiDirectionStats = new FfiConverterOptional(
  FfiConverterTypeFfiDirectionStats,
);

// FfiConverter for FfiFrequentSection | undefined
const FfiConverterOptionalTypeFfiFrequentSection = new FfiConverterOptional(
  FfiConverterTypeFfiFrequentSection,
);

// FfiConverter for FfiRouteGroup | undefined
const FfiConverterOptionalTypeFfiRouteGroup = new FfiConverterOptional(
  FfiConverterTypeFfiRouteGroup,
);

// FfiConverter for FfiRoutePerformance | undefined
const FfiConverterOptionalTypeFfiRoutePerformance = new FfiConverterOptional(
  FfiConverterTypeFfiRoutePerformance,
);

// FfiConverter for FfiRoutesScreenData | undefined
const FfiConverterOptionalTypeFfiRoutesScreenData = new FfiConverterOptional(
  FfiConverterTypeFfiRoutesScreenData,
);

// FfiConverter for FfiSectionPerformanceRecord | undefined
const FfiConverterOptionalTypeFfiSectionPerformanceRecord =
  new FfiConverterOptional(FfiConverterTypeFfiSectionPerformanceRecord);

// FfiConverter for PersistentEngineStats | undefined
const FfiConverterOptionalTypePersistentEngineStats = new FfiConverterOptional(
  FfiConverterTypePersistentEngineStats,
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u16*/number | undefined
const FfiConverterOptionalUInt16 = new FfiConverterOptional(FfiConverterUInt16);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for Array</*f64*/number>
const FfiConverterArrayFloat64 = new FfiConverterArray(FfiConverterFloat64);

// FfiConverter for Array<ActivitySportMapping>
const FfiConverterArrayTypeActivitySportMapping = new FfiConverterArray(
  FfiConverterTypeActivitySportMapping,
);

// FfiConverter for Array<ActivitySportType>
const FfiConverterArrayTypeActivitySportType = new FfiConverterArray(
  FfiConverterTypeActivitySportType,
);

// FfiConverter for Array<FfiActivityMapResult>
const FfiConverterArrayTypeFfiActivityMapResult = new FfiConverterArray(
  FfiConverterTypeFfiActivityMapResult,
);

// FfiConverter for Array<FfiActivityMetrics>
const FfiConverterArrayTypeFfiActivityMetrics = new FfiConverterArray(
  FfiConverterTypeFfiActivityMetrics,
);

// FfiConverter for Array<FfiBatchTrace>
const FfiConverterArrayTypeFfiBatchTrace = new FfiConverterArray(
  FfiConverterTypeFfiBatchTrace,
);

// FfiConverter for Array<FfiFrequentSection>
const FfiConverterArrayTypeFfiFrequentSection = new FfiConverterArray(
  FfiConverterTypeFfiFrequentSection,
);

// FfiConverter for Array<FfiGpsPoint>
const FfiConverterArrayTypeFfiGpsPoint = new FfiConverterArray(
  FfiConverterTypeFfiGpsPoint,
);

// FfiConverter for Array<FfiGroupWithPolyline>
const FfiConverterArrayTypeFfiGroupWithPolyline = new FfiConverterArray(
  FfiConverterTypeFfiGroupWithPolyline,
);

// FfiConverter for Array<FfiHeatmapDay>
const FfiConverterArrayTypeFfiHeatmapDay = new FfiConverterArray(
  FfiConverterTypeFfiHeatmapDay,
);

// FfiConverter for Array<FfiMonthlyAggregate>
const FfiConverterArrayTypeFfiMonthlyAggregate = new FfiConverterArray(
  FfiConverterTypeFfiMonthlyAggregate,
);

// FfiConverter for Array<FfiPotentialSection>
const FfiConverterArrayTypeFfiPotentialSection = new FfiConverterArray(
  FfiConverterTypeFfiPotentialSection,
);

// FfiConverter for Array<FfiRouteGroup>
const FfiConverterArrayTypeFfiRouteGroup = new FfiConverterArray(
  FfiConverterTypeFfiRouteGroup,
);

// FfiConverter for Array<FfiRoutePerformance>
const FfiConverterArrayTypeFfiRoutePerformance = new FfiConverterArray(
  FfiConverterTypeFfiRoutePerformance,
);

// FfiConverter for Array<FfiScalePreset>
const FfiConverterArrayTypeFfiScalePreset = new FfiConverterArray(
  FfiConverterTypeFfiScalePreset,
);

// FfiConverter for Array<FfiSection>
const FfiConverterArrayTypeFfiSection = new FfiConverterArray(
  FfiConverterTypeFfiSection,
);

// FfiConverter for Array<FfiSectionLap>
const FfiConverterArrayTypeFfiSectionLap = new FfiConverterArray(
  FfiConverterTypeFfiSectionLap,
);

// FfiConverter for Array<FfiSectionPerformanceRecord>
const FfiConverterArrayTypeFfiSectionPerformanceRecord = new FfiConverterArray(
  FfiConverterTypeFfiSectionPerformanceRecord,
);

// FfiConverter for Array<FfiSectionPortion>
const FfiConverterArrayTypeFfiSectionPortion = new FfiConverterArray(
  FfiConverterTypeFfiSectionPortion,
);

// FfiConverter for Array<FfiSectionWithPolyline>
const FfiConverterArrayTypeFfiSectionWithPolyline = new FfiConverterArray(
  FfiConverterTypeFfiSectionWithPolyline,
);

// FfiConverter for Array<GroupSummary>
const FfiConverterArrayTypeGroupSummary = new FfiConverterArray(
  FfiConverterTypeGroupSummary,
);

// FfiConverter for Array<MapActivityComplete>
const FfiConverterArrayTypeMapActivityComplete = new FfiConverterArray(
  FfiConverterTypeMapActivityComplete,
);

// FfiConverter for Array<SectionSummary>
const FfiConverterArrayTypeSectionSummary = new FfiConverterArray(
  FfiConverterTypeSectionSummary,
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u32*/number>
const FfiConverterArrayUInt32 = new FfiConverterArray(FfiConverterUInt32);

// FfiConverter for Array<FfiActivityMapResult> | undefined
const FfiConverterOptionalArrayTypeFfiActivityMapResult =
  new FfiConverterOptional(FfiConverterArrayTypeFfiActivityMapResult);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString,
);

// FfiConverter for Array</*u32*/number> | undefined
const FfiConverterOptionalArrayUInt32 = new FfiConverterOptional(
  FfiConverterArrayUInt32,
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_veloqrs_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_compute_polyline_overlap() !==
    29438
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_compute_polyline_overlap",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_create_section() !== 37537
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_create_section",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_default_scale_presets() !==
    21857
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_default_scale_presets",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_delete_section() !== 33248
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_delete_section",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_fetch_activity_maps() !==
    10533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_fetch_activity_maps",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_fetch_activity_maps_with_progress() !==
    28890
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_fetch_activity_maps_with_progress",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_ffi_detect_sections_multiscale() !==
    58741
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_ffi_detect_sections_multiscale",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_get_download_progress() !==
    18164
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_get_download_progress",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_get_section_count() !==
    34222
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_get_section_count",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_get_section_reference() !==
    53900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_get_section_reference",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_get_sections() !== 61666
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_get_sections",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_get_sections_for_activity() !==
    7087
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_get_sections_for_activity",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_is_section_reference_user_defined() !==
    27641
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_is_section_reference_user_defined",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_add_activities() !==
    36907
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_add_activities",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_cleanup_old_activities() !==
    30709
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_cleanup_old_activities",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_clear() !==
    3704
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_clear",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_detect_potentials() !==
    14751
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_detect_potentials",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_extract_section_trace() !==
    54804
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_extract_section_trace",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_extract_section_traces_batch() !==
    6539
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_extract_section_traces_batch",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_activities_missing_time_streams() !==
    17851
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_activities_missing_time_streams",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_activity_count() !==
    6013
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_activity_count",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_activity_heatmap() !==
    32573
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_activity_heatmap",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_activity_ids() !==
    41837
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_activity_ids",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_activity_metrics_for_ids() !==
    44538
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_activity_metrics_for_ids",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_all_map_activities_complete() !==
    61778
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_all_map_activities_complete",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_all_route_names() !==
    49074
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_all_route_names",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_all_section_names() !==
    19302
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_all_section_names",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_athlete_profile() !==
    58998
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_athlete_profile",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_available_sport_types() !==
    20801
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_available_sport_types",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_consensus_route() !==
    41984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_consensus_route",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_ftp_trend() !==
    15108
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_ftp_trend",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_gps_track() !==
    18900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_gps_track",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_group_by_id() !==
    57631
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_group_by_id",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_group_count() !==
    47711
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_group_count",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_group_summaries() !==
    39213
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_group_summaries",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_groups() !==
    48377
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_groups",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_map_activities_filtered() !==
    43230
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_map_activities_filtered",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_monthly_aggregates() !==
    58996
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_monthly_aggregates",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_period_stats() !==
    18491
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_period_stats",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_route_name() !==
    13569
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_route_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_route_performances() !==
    62886
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_route_performances",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_routes_screen_data() !==
    32474
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_routes_screen_data",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_by_id() !==
    39799
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_by_id",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_count() !==
    54975
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_count",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_detection_progress() !==
    27049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_detection_progress",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_performances() !==
    49656
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_performances",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_polyline() !==
    33686
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_polyline",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_summaries() !==
    38826
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_summaries",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_section_summaries_for_sport() !==
    31441
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_section_summaries_for_sport",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_sections() !==
    25881
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_sections",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_sport_settings() !==
    44569
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_sport_settings",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_stats() !==
    61109
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_stats",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_get_zone_distribution() !==
    40466
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_get_zone_distribution",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_init() !==
    24670
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_init",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_is_initialized() !==
    54372
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_is_initialized",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_mark_for_recomputation() !==
    42498
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_mark_for_recomputation",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_poll_sections() !==
    32166
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_poll_sections",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_query_viewport() !==
    32191
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_query_viewport",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_activity_metrics() !==
    42378
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_activity_metrics",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_athlete_profile() !==
    8308
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_athlete_profile",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_name_translations() !==
    62206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_name_translations",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_route_name() !==
    19245
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_route_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_section_name() !==
    15280
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_section_name",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_sport_settings() !==
    45199
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_sport_settings",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_set_time_streams_flat() !==
    39274
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_set_time_streams_flat",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_persistent_engine_start_section_detection() !==
    42642
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_persistent_engine_start_section_detection",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_rename_section() !== 62131
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_rename_section",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_reset_section_reference() !==
    29790
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_reset_section_reference",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_set_section_reference() !==
    26095
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_set_section_reference",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_start_background_fetch() !==
    29608
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_start_background_fetch",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_start_fetch_and_store() !==
    40795
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_start_fetch_and_store",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_take_background_fetch_results() !==
    32634
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_take_background_fetch_results",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_func_take_fetch_and_store_result() !==
    50568
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_func_take_fetch_and_store_result",
    );
  }
  if (
    nativeModule().ubrn_uniffi_veloqrs_checksum_method_fetchprogresscallback_on_progress() !==
    64082
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_veloqrs_checksum_method_fetchprogresscallback_on_progress",
    );
  }

  uniffiCallbackInterfaceFetchProgressCallback.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeActivitySectionMatch,
    FfiConverterTypeActivitySportMapping,
    FfiConverterTypeActivitySportType,
    FfiConverterTypeDownloadProgressResult,
    FfiConverterTypeFetchAndStoreResult,
    FfiConverterTypeFfiActivityMapResult,
    FfiConverterTypeFfiActivityMetrics,
    FfiConverterTypeFfiBatchTrace,
    FfiConverterTypeFfiBounds,
    FfiConverterTypeFfiDetectionStats,
    FfiConverterTypeFfiDirectionStats,
    FfiConverterTypeFfiFrequentSection,
    FfiConverterTypeFfiFtpTrend,
    FfiConverterTypeFfiGpsPoint,
    FfiConverterTypeFfiGroupWithPolyline,
    FfiConverterTypeFfiHeatmapDay,
    FfiConverterTypeFfiMonthlyAggregate,
    FfiConverterTypeFfiMultiScaleSectionResult,
    FfiConverterTypeFfiPeriodStats,
    FfiConverterTypeFfiPotentialSection,
    FfiConverterTypeFfiRouteGroup,
    FfiConverterTypeFfiRoutePerformance,
    FfiConverterTypeFfiRoutePerformanceResult,
    FfiConverterTypeFfiRouteSignature,
    FfiConverterTypeFfiRoutesScreenData,
    FfiConverterTypeFfiScalePreset,
    FfiConverterTypeFfiSection,
    FfiConverterTypeFfiSectionConfig,
    FfiConverterTypeFfiSectionLap,
    FfiConverterTypeFfiSectionPerformanceRecord,
    FfiConverterTypeFfiSectionPerformanceResult,
    FfiConverterTypeFfiSectionPortion,
    FfiConverterTypeFfiSectionWithPolyline,
    FfiConverterTypeGroupSummary,
    FfiConverterTypeMapActivityComplete,
    FfiConverterTypeMapActivityData,
    FfiConverterTypePersistentEngineStats,
    FfiConverterTypeSectionSummary,
  },
});
