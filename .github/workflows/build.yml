name: Build iOS & Android

on:
  push:
    branches: [main]
    # Tags handled by release.yml (artifact promotion)
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      build_type:
        description: "Build type override"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - preview
          - production

env:
  NODE_VERSION: "20"

jobs:
  # ============================================
  # Parallel Tests (HIGH IMPACT: ~2-3 min faster)
  # ============================================
  test:
    name: Test (${{ matrix.name }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: typescript
            cmd: npx tsc --noEmit
          - name: format
            cmd: npm run format:check
          - name: jest
            cmd: npm test -- --maxWorkers=2
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Run ${{ matrix.name }}
        run: ${{ matrix.cmd }}

  # ============================================
  # Verify Signing Keys (fail fast)
  # ============================================
  verify-signing:
    name: Verify Signing (${{ matrix.platform }})
    runs-on: ${{ matrix.runs-on }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: android
            runs-on: ubuntu-latest
          - platform: ios
            runs-on: macos-15
    steps:
      # ---- Android Signing Verification ----
      - name: Verify Android signing
        if: matrix.platform == 'android'
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          EXPECTED_SHA1: "0D:54:88:9C:F2:AF:55:09:8F:40:35:E8:54:66:17:F8:30:FD:0D:86"
        run: |
          echo "=== Verifying Android signing configuration ==="

          # Verify all required secrets are set
          MISSING=""
          [ -z "$ANDROID_KEYSTORE_BASE64" ] && MISSING="$MISSING ANDROID_KEYSTORE_BASE64"
          [ -z "$ANDROID_KEYSTORE_PASSWORD" ] && MISSING="$MISSING ANDROID_KEYSTORE_PASSWORD"
          [ -z "$ANDROID_KEY_ALIAS" ] && MISSING="$MISSING ANDROID_KEY_ALIAS"
          [ -z "$ANDROID_KEY_PASSWORD" ] && MISSING="$MISSING ANDROID_KEY_PASSWORD"

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required secrets:$MISSING"
            exit 1
          fi

          # Decode keystore and verify fingerprint
          echo "$ANDROID_KEYSTORE_BASE64" | tr -d ' \n\r\t' | base64 -d > /tmp/release.keystore

          if [ ! -f /tmp/release.keystore ]; then
            echo "::error::Failed to decode keystore"
            exit 1
          fi

          SIZE=$(stat -c%s /tmp/release.keystore 2>/dev/null || stat -f%z /tmp/release.keystore)
          echo "Keystore file size: $SIZE bytes"

          if [ "$SIZE" -lt 1000 ]; then
            echo "::error::Keystore file too small ($SIZE bytes) - likely corrupted base64"
            exit 1
          fi

          # Verify fingerprint
          KEYTOOL_OUTPUT=$(keytool -list -v -keystore /tmp/release.keystore -storepass "$ANDROID_KEYSTORE_PASSWORD" 2>&1) || {
            echo "::error::keytool failed - wrong password or corrupted keystore"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          }

          ACTUAL_SHA1=$(echo "$KEYTOOL_OUTPUT" | grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')
          echo "Expected SHA1: $EXPECTED_SHA1"
          echo "Actual SHA1:   $ACTUAL_SHA1"

          if [ -z "$ACTUAL_SHA1" ]; then
            echo "::error::Could not extract SHA1 from keytool output"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          fi

          if [ "$ACTUAL_SHA1" != "$EXPECTED_SHA1" ]; then
            echo "::error::Keystore fingerprint mismatch! Expected Play Store upload key."
            exit 1
          fi

          echo "âœ… Android signing verified"
          rm /tmp/release.keystore

      # ---- iOS Signing Verification (main branch only) ----
      - name: Checkout repository
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: actions/checkout@v4

      - name: Check iOS signing secrets
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_SSH_PRIVATE_KEY: ${{ secrets.MATCH_SSH_PRIVATE_KEY }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_API_KEY: ${{ secrets.ASC_API_KEY }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        run: |
          echo "=== Verifying iOS signing configuration ==="

          missing=()
          [ -z "$MATCH_GIT_URL" ] && missing+=("MATCH_GIT_URL")
          [ -z "$MATCH_PASSWORD" ] && missing+=("MATCH_PASSWORD")
          [ -z "$MATCH_SSH_PRIVATE_KEY" ] && missing+=("MATCH_SSH_PRIVATE_KEY")
          [ -z "$ASC_KEY_ID" ] && missing+=("ASC_KEY_ID")
          [ -z "$ASC_ISSUER_ID" ] && missing+=("ASC_ISSUER_ID")
          [ -z "$ASC_API_KEY" ] && missing+=("ASC_API_KEY")
          [ -z "$FASTLANE_TEAM_ID" ] && missing+=("FASTLANE_TEAM_ID")

          if [ ${#missing[@]} -gt 0 ]; then
            echo "::error::Missing iOS signing secrets: ${missing[*]}"
            exit 1
          fi

          echo "âœ… All iOS signing secrets configured"

      - name: Setup SSH for Match
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.MATCH_SSH_PRIVATE_KEY }}

      - name: Verify Match repository access
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
        run: |
          echo "=== Testing Match repository access ==="
          git ls-remote "$MATCH_GIT_URL" &>/dev/null || {
            echo "::error::Cannot access Match repository at $MATCH_GIT_URL"
            exit 1
          }
          echo "âœ… Match repository accessible"

      - name: Setup Ruby
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true
          working-directory: fastlane

      - name: Verify certificates via Match
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        working-directory: fastlane
        run: |
          echo "=== Syncing certificates from Match (readonly) ==="
          bundle exec fastlane match appstore --readonly --verbose

      - name: Check certificate expiration
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          echo "=== Checking certificate expiration ==="

          # Find distribution certificate in keychain
          CERT_INFO=$(security find-certificate -c "Apple Distribution" -p login.keychain 2>/dev/null || \
                      security find-certificate -c "iPhone Distribution" -p login.keychain 2>/dev/null || true)

          if [ -z "$CERT_INFO" ]; then
            echo "::warning::Could not find distribution certificate in keychain"
            exit 0
          fi

          # Extract expiration date
          EXPIRY=$(echo "$CERT_INFO" | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          echo "ðŸ“œ Certificate expires: $EXPIRY"

          # Check if expiring within 30 days (2592000 seconds)
          if echo "$CERT_INFO" | openssl x509 -checkend 2592000 > /dev/null 2>&1; then
            echo "âœ… Certificate valid for 30+ days"
          else
            echo "::warning::âš ï¸ Certificate expires within 30 days! Consider renewing soon."
          fi

          # Check if expiring within 7 days (604800 seconds) - this is critical
          if ! echo "$CERT_INFO" | openssl x509 -checkend 604800 > /dev/null 2>&1; then
            echo "::error::Certificate expires within 7 days! Immediate action required."
            exit 1
          fi

          echo "âœ… iOS signing verification complete"

  # ============================================
  # Build Android
  # ============================================
  build-android:
    name: Build Android APK
    needs: [test, verify-signing]
    runs-on: ubuntu-latest
    env:
      # Fix Maven Central 403 errors by setting User-Agent header
      # JAVA_TOOL_OPTIONS affects all JVM processes including Gradle daemon and forks
      JAVA_TOOL_OPTIONS: "-Dhttp.agent=Gradle -Dhttps.agent=Gradle"
      GRADLE_OPTS: "-Dhttp.agent=Gradle -Dhttps.agent=Gradle"
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_code: ${{ steps.version.outputs.version_code }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      filename: ${{ steps.version.outputs.filename }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          BUILD_TYPE="preview"
          IS_RELEASE="false"

          if [[ "${{ inputs.build_type }}" != "" && "${{ inputs.build_type }}" != "auto" ]]; then
            BUILD_TYPE="${{ inputs.build_type }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            BUILD_TYPE="production"
            IS_RELEASE="true"
          fi

          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "production" ]]; then
            echo "filename=veloq-${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "filename=veloq-${VERSION}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "Build type: $BUILD_TYPE | Version: $VERSION ($VERSION_CODE)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # Use official Gradle action for better dependency caching
      # This reduces Maven Central requests and helps avoid IP blocking
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-read-only: false
          gradle-home-cache-includes: |
            caches
            notifications
            wrapper

      - name: Cache Android build outputs
        uses: actions/cache@v4
        with:
          path: |
            android/.gradle
            android/app/build
            android/app/.cxx
            android/build
          key: android-build-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            android-build-${{ runner.os }}-

      - name: Cache Metro bundler
        uses: actions/cache@v4
        with:
          path: |
            /tmp/metro-*
            node_modules/.cache
          key: metro-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            metro-${{ runner.os }}-

      - name: Cache React Native library builds
        uses: actions/cache@v4
        with:
          path: |
            node_modules/**/android/build
            node_modules/**/android/.cxx
          key: rn-libs-build-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            rn-libs-build-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Download tracematch binaries from GitHub releases
        run: |
          TRACEMATCH_VERSION=$(node -p "require('./package.json').tracematchVersion")
          echo "=== Downloading tracematch v${TRACEMATCH_VERSION} ==="
          RELEASE_URL="https://github.com/evanjt/route-matcher/releases/download/${TRACEMATCH_VERSION}"

          # Download Android binaries
          curl -sL "${RELEASE_URL}/tracematch-android-${TRACEMATCH_VERSION}.zip" -o /tmp/android.zip
          unzip -q /tmp/android.zip -d /tmp/tracematch

          # Install .so files
          mkdir -p modules/route-matcher-native/android/src/main/jniLibs
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            mkdir -p "modules/route-matcher-native/android/src/main/jniLibs/$arch"
            cp "/tmp/tracematch/android/jniLibs/$arch/libtracematch.so" \
               "modules/route-matcher-native/android/src/main/jniLibs/$arch/"
            echo "âœ“ Installed $arch"
          done

          # Install Kotlin bindings
          mkdir -p modules/route-matcher-native/android/src/main/java/uniffi/tracematch
          cp /tmp/tracematch/android/kotlin/uniffi/tracematch/tracematch.kt \
             modules/route-matcher-native/android/src/main/java/uniffi/tracematch/
          echo "âœ“ Installed Kotlin bindings"

          # Verify installation
          echo "=== Verifying installation ==="
          find modules/route-matcher-native/android/src/main/jniLibs -name "*.so" -exec ls -lh {} \;
          ls -la modules/route-matcher-native/android/src/main/java/uniffi/tracematch/

      - name: Cache Android prebuild
        id: android-prebuild-cache
        uses: actions/cache@v4
        with:
          path: android
          key: android-prebuild-${{ runner.os }}-${{ hashFiles('app.json', 'package.json', 'package-lock.json', 'plugins/**', 'expo-modules/**/*.json', 'modules/**/android/**', 'node_modules/react-native-vector-icons/package.json', 'node_modules/react-native-webview/package.json') }}
          restore-keys: |
            android-prebuild-${{ runner.os }}-

      - name: Generate Android native project
        if: steps.android-prebuild-cache.outputs.cache-hit != 'true'
        run: npx expo prebuild --platform android

      # Create Gradle init script to fix Maven Central 403 errors
      # Forces all Maven Central requests through repo1.maven.org mirror
      - name: Create Gradle init script for CI
        run: |
          mkdir -p ~/.gradle
          echo "ZGVmIHJlcG9VcmwgPSAiaHR0cHM6Ly9yZXBvMS5tYXZlbi5vcmcvbWF2ZW4yLyIKCmJlZm9yZVNldHRpbmdzIHsgc2V0dGluZ3MgLT4KICBzZXR0aW5ncy5wbHVnaW5NYW5hZ2VtZW50IHsKICAgIHJlcG9zaXRvcmllcyB7CiAgICAgIG1hdmVuIHsgdXJsID0gdXJpKHJlcG9VcmwpOyBuYW1lID0gIk1hdmVuQ2VudHJhbE1pcnJvciIgfQogICAgICBncmFkbGVQbHVnaW5Qb3J0YWwoKQogICAgICBnb29nbGUoKQogICAgfQogIH0KfQoKc2V0dGluZ3NFdmFsdWF0ZWQgeyBzZXR0aW5ncyAtPgogIHNldHRpbmdzLnBsdWdpbk1hbmFnZW1lbnQgewogICAgcmVwb3NpdG9yaWVzIHsKICAgICAgY2xlYXIoKQogICAgICBtYXZlbiB7IHVybCA9IHVyaShyZXBvVXJsKTsgbmFtZSA9ICJNYXZlbkNlbnRyYWxNaXJyb3IiIH0KICAgICAgZ3JhZGxlUGx1Z2luUG9ydGFsKCkKICAgICAgZ29vZ2xlKCkKICAgIH0KICB9Cn0KCmFsbHByb2plY3RzIHsKICBidWlsZHNjcmlwdCB7CiAgICByZXBvc2l0b3JpZXMgewogICAgICBtYXZlbiB7IHVybCA9IHVyaShyZXBvVXJsKTsgbmFtZSA9ICJNYXZlbkNlbnRyYWxNaXJyb3IiIH0KICAgICAgZ29vZ2xlKCkKICAgIH0KICB9CiAgcmVwb3NpdG9yaWVzIHsKICAgIG1hdmVuIHsgdXJsID0gdXJpKHJlcG9VcmwpOyBuYW1lID0gIk1hdmVuQ2VudHJhbE1pcnJvciIgfQogICAgZ29vZ2xlKCkKICB9Cn0K" | base64 -d > ~/.gradle/init.gradle
          echo "=== init.gradle contents ==="
          cat ~/.gradle/init.gradle

      # Setup signing AFTER prebuild creates android/ directory
      - name: Setup signing
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          # Keystore was already verified earlier - just decode to final location
          mkdir -p android/app
          echo "$ANDROID_KEYSTORE_BASE64" | tr -d ' \n\r\t' | base64 -d > android/app/release.keystore

          # Create keystore.properties
          printf '%s\n' \
            "storeFile=release.keystore" \
            "storePassword=$ANDROID_KEYSTORE_PASSWORD" \
            "keyAlias=$ANDROID_KEY_ALIAS" \
            "keyPassword=$ANDROID_KEY_PASSWORD" \
            > android/keystore.properties

          echo "âœ… Signing configured"

      - name: Verify tracematch libraries before build
        run: |
          echo "=== Verifying .so files before Gradle build ==="

          # Check if jniLibs directory exists
          if [ ! -d "modules/route-matcher-native/android/src/main/jniLibs" ]; then
            echo "ERROR: jniLibs directory not found!"
            exit 1
          fi

          # Verify each architecture
          all_ok=true
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            so_file="modules/route-matcher-native/android/src/main/jniLibs/$arch/libtracematch.so"
            if [ -f "$so_file" ]; then
              size=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null || echo "0")
              if [ "$size" -gt 0 ]; then
                echo "âœ“ $arch: ${size} bytes"
              else
                echo "âœ— $arch: FILE EXISTS BUT IS EMPTY!"
                all_ok=false
              fi
            else
              echo "âœ— $arch: FILE NOT FOUND at $so_file"
              all_ok=false
            fi
          done

          # Verify Kotlin bindings
          KOTLIN_BINDING="modules/route-matcher-native/android/src/main/java/uniffi/tracematch/tracematch.kt"
          if [ -f "$KOTLIN_BINDING" ]; then
            echo "âœ“ Kotlin bindings: $KOTLIN_BINDING"
          else
            echo "âœ— Kotlin bindings not found"
            all_ok=false
          fi

          if [ "$all_ok" = "false" ]; then
            echo "ERROR: tracematch libraries verification failed!"
            exit 1
          fi

          echo "âœ… All tracematch libraries verified!"

      - name: Build Android APK
        env:
          RUST_PREBUILT: "true"
        run: |
          cd android && ./gradlew assembleRelease --no-daemon

      - name: Copy APK
        run: |
          mkdir -p artifacts
          if [ ! -f android/keystore.properties ]; then
            echo "::error::keystore.properties not found - release builds must be signed"
            exit 1
          fi
          cp android/app/build/outputs/apk/release/app-release.apk \
            "artifacts/${{ steps.version.outputs.filename }}.apk"

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-apk-${{ steps.version.outputs.filename }}
          path: artifacts/*.apk
          retention-days: 30

      - name: Build AAB for Play Store
        # Build AAB on main branch (needed for release artifact promotion)
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        env:
          RUST_PREBUILT: "true"
        run: |
          # Android folder and dependencies are already set up from APK build
          # Just run Gradle to build the AAB
          cd android && ./gradlew bundleRelease --no-daemon

      - name: Rename AAB
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: |
          AAB_PATH=$(find android/app/build/outputs/bundle -name "*.aab" | head -1)
          if [ -n "$AAB_PATH" ]; then
            cp "$AAB_PATH" "artifacts/${{ steps.version.outputs.filename }}.aab"
          fi

      - name: Upload AAB artifact
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: android-aab-${{ steps.version.outputs.filename }}
          path: artifacts/*.aab
          retention-days: 30

      - name: Verify AAB signing
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        env:
          EXPECTED_SHA1: "0D:54:88:9C:F2:AF:55:09:8F:40:35:E8:54:66:17:F8:30:FD:0D:86"
        run: |
          echo "=== Verifying AAB was signed with correct key ==="
          AAB_FILE="artifacts/${{ steps.version.outputs.filename }}.aab"

          if [ ! -f "$AAB_FILE" ]; then
            echo "::error::AAB file not found at $AAB_FILE"
            exit 1
          fi

          # AABs use JAR signing (v1) so we can extract from META-INF
          # Unlike APKs, AABs don't support v2/v3 signature schemes
          ACTUAL_SHA1=$(unzip -p "$AAB_FILE" "META-INF/BNDLTOOL.RSA" 2>/dev/null | \
            keytool -printcert 2>/dev/null | \
            grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')

          # Fallback: try any .RSA file if BNDLTOOL.RSA doesn't exist
          if [ -z "$ACTUAL_SHA1" ]; then
            RSA_FILE=$(unzip -l "$AAB_FILE" 2>/dev/null | grep "META-INF/.*\.RSA" | awk '{print $4}' | head -1)
            if [ -n "$RSA_FILE" ]; then
              ACTUAL_SHA1=$(unzip -p "$AAB_FILE" "$RSA_FILE" 2>/dev/null | \
                keytool -printcert 2>/dev/null | \
                grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')
            fi
          fi

          echo "Expected SHA1: $EXPECTED_SHA1"
          echo "Actual SHA1:   $ACTUAL_SHA1"

          if [ -z "$ACTUAL_SHA1" ]; then
            echo "::error::Could not extract signing certificate from AAB"
            echo "AAB contents:"
            unzip -l "$AAB_FILE" | grep -i "meta-inf" || echo "No META-INF found"
            exit 1
          fi

          if [ "$ACTUAL_SHA1" != "$EXPECTED_SHA1" ]; then
            echo "::error::AAB signed with WRONG KEY!"
            echo "::error::Expected Play Store upload key but got different certificate"
            exit 1
          fi

          echo "âœ… AAB signed with correct release key"

  # ============================================
  # Build iOS
  # ============================================
  build-ios:
    name: Build iOS App
    needs: [test, verify-signing]
    runs-on: macos-15
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_code: ${{ steps.version.outputs.version_code }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      filename: ${{ steps.version.outputs.filename }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          BUILD_TYPE="preview"
          IS_RELEASE="false"

          if [[ "${{ inputs.build_type }}" != "" && "${{ inputs.build_type }}" != "auto" ]]; then
            BUILD_TYPE="${{ inputs.build_type }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            BUILD_TYPE="production"
            IS_RELEASE="true"
          fi

          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "production" ]]; then
            echo "filename=veloq-${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "filename=veloq-${VERSION}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "Build type: $BUILD_TYPE | Version: $VERSION ($VERSION_CODE)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      # ============================================
      # Download tracematch binaries
      # ============================================
      - name: Download tracematch binaries from GitHub releases
        run: |
          TRACEMATCH_VERSION=$(node -p "require('./package.json').tracematchVersion")
          echo "=== Downloading tracematch v${TRACEMATCH_VERSION} for iOS ==="
          RELEASE_URL="https://github.com/evanjt/route-matcher/releases/download/${TRACEMATCH_VERSION}"

          # Download iOS binaries
          curl -sL "${RELEASE_URL}/tracematch-ios-${TRACEMATCH_VERSION}.zip" -o /tmp/ios.zip
          unzip -q /tmp/ios.zip -d /tmp/tracematch

          # Install XCFramework
          mkdir -p modules/route-matcher-native/ios/Frameworks
          cp -r /tmp/tracematch/ios/RouteMatcherFFI.xcframework \
                modules/route-matcher-native/ios/Frameworks/
          echo "âœ“ Installed XCFramework"

          # Install Swift bindings
          mkdir -p modules/route-matcher-native/ios/Generated
          cp /tmp/tracematch/ios/Generated/tracematch.swift \
             modules/route-matcher-native/ios/Generated/
          cp /tmp/tracematch/ios/Generated/tracematchFFI.h \
             modules/route-matcher-native/ios/Generated/
          cp /tmp/tracematch/ios/Generated/tracematchFFI.modulemap \
             modules/route-matcher-native/ios/Generated/
          echo "âœ“ Installed Swift bindings"

          # Verify
          ls -la modules/route-matcher-native/ios/Frameworks/
          ls -la modules/route-matcher-native/ios/Generated/

      - name: Cache iOS prebuild
        id: ios-prebuild-cache
        uses: actions/cache@v4
        with:
          path: ios
          key: ios-prebuild-${{ runner.os }}-${{ hashFiles('app.json', 'package.json', 'plugins/**', 'expo-modules/**/*.json', 'modules/**/ios/**') }}
          restore-keys: |
            ios-prebuild-${{ runner.os }}-

      # ============================================
      # iOS Build
      # ============================================
      - name: Install dependencies
        run: npm ci

      - name: Generate native project
        if: steps.ios-prebuild-cache.outputs.cache-hit != 'true'
        run: npx expo prebuild --platform ios

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ios/Pods
            ~/Library/Caches/CocoaPods
          key: cocoapods-${{ runner.os }}-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            cocoapods-${{ runner.os }}-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true
          working-directory: fastlane

      - name: Install Pods
        if: steps.ios-prebuild-cache.outputs.cache-hit != 'true'
        working-directory: ios
        run: pod install

      # ============================================
      # iOS Signing (for IPA builds on main)
      # ============================================
      - name: Check for iOS signing credentials
        id: check_ios_signing
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
        run: |
          if [ -n "$MATCH_GIT_URL" ] && [ -n "$ASC_KEY_ID" ]; then
            echo "has_signing=true" >> $GITHUB_OUTPUT
            echo "âœ… iOS signing credentials found"
          else
            echo "has_signing=false" >> $GITHUB_OUTPUT
            echo "::notice::iOS signing not configured - skipping IPA build"
          fi

      - name: Setup SSH for Match
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.MATCH_SSH_PRIVATE_KEY }}

      - name: Sync certificates with Match
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        working-directory: fastlane
        run: bundle exec fastlane match appstore --readonly

      - name: Build signed IPA
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        working-directory: fastlane
        run: bundle exec fastlane ios build_release

      - name: Rename IPA
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          mkdir -p artifacts
          IPA_PATH=$(find . -name "*.ipa" -type f | head -1)
          if [ -n "$IPA_PATH" ]; then
            cp "$IPA_PATH" "artifacts/${{ steps.version.outputs.filename }}.ipa"
            echo "âœ… IPA: ${{ steps.version.outputs.filename }}.ipa"
          fi

      - name: Verify IPA code signature
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          EXPECTED_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
          EXPECTED_BUNDLE_ID: "com.veloq.app"
        run: |
          echo "=== Verifying IPA code signature ==="
          IPA_FILE="artifacts/${{ steps.version.outputs.filename }}.ipa"

          if [ ! -f "$IPA_FILE" ]; then
            echo "::error::IPA file not found at $IPA_FILE"
            exit 1
          fi

          # Extract IPA
          rm -rf /tmp/ipa_verify
          mkdir -p /tmp/ipa_verify
          unzip -q "$IPA_FILE" -d /tmp/ipa_verify

          # Find .app bundle
          APP_PATH=$(find /tmp/ipa_verify -name "*.app" -type d | head -1)
          if [ -z "$APP_PATH" ]; then
            echo "::error::No .app bundle found in IPA"
            exit 1
          fi

          echo "Found app: $APP_PATH"

          # Verify code signature
          echo "--- Code Signature Details ---"
          codesign -dv --verbose=2 "$APP_PATH" 2>&1 | tee /tmp/codesign.txt || {
            echo "::error::IPA is not properly signed"
            exit 1
          }

          # Extract and verify Team ID
          ACTUAL_TEAM=$(grep "TeamIdentifier=" /tmp/codesign.txt | cut -d= -f2)
          echo "Expected Team ID: $EXPECTED_TEAM_ID"
          echo "Actual Team ID:   $ACTUAL_TEAM"

          if [ "$ACTUAL_TEAM" != "$EXPECTED_TEAM_ID" ]; then
            echo "::error::Team ID mismatch! Expected $EXPECTED_TEAM_ID but got $ACTUAL_TEAM"
            exit 1
          fi

          # Extract and verify Bundle ID from Info.plist
          ACTUAL_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print CFBundleIdentifier" "$APP_PATH/Info.plist" 2>/dev/null)
          echo "Expected Bundle ID: $EXPECTED_BUNDLE_ID"
          echo "Actual Bundle ID:   $ACTUAL_BUNDLE_ID"

          if [ "$ACTUAL_BUNDLE_ID" != "$EXPECTED_BUNDLE_ID" ]; then
            echo "::error::Bundle ID mismatch! Expected $EXPECTED_BUNDLE_ID but got $ACTUAL_BUNDLE_ID"
            exit 1
          fi

          # Verify signature is valid
          codesign --verify --deep --strict "$APP_PATH" 2>&1 || {
            echo "::error::Code signature verification failed"
            exit 1
          }

          # Cleanup
          rm -rf /tmp/ipa_verify

          echo "âœ… IPA signed correctly by team $ACTUAL_TEAM with bundle ID $ACTUAL_BUNDLE_ID"

      - name: Upload IPA artifact
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-${{ steps.version.outputs.filename }}
          path: artifacts/*.ipa
          retention-days: 30

      # ============================================
      # iOS Simulator Build (always runs)
      # ============================================
      - name: Build iOS Simulator app
        run: |
          xcodebuild -workspace ios/veloq.xcworkspace \
            -scheme Veloq \
            -configuration Release \
            -sdk iphonesimulator \
            -arch x86_64 \
            -derivedDataPath ios/build \
            CODE_SIGNING_ALLOWED=NO \
            2>&1 | tee build.log || (echo "=== Build failed, showing last 100 lines ===" && tail -100 build.log && exit 1)

      - name: Package .app
        run: |
          mkdir -p artifacts
          APP_PATH=$(find ios/build/Build/Products/Release-iphonesimulator -name "*.app" -type d | head -1)
          if [ -n "$APP_PATH" ]; then
            cd "$(dirname "$APP_PATH")"
            zip -r "$GITHUB_WORKSPACE/artifacts/${{ steps.version.outputs.filename }}-ios-simulator.zip" "$(basename "$APP_PATH")"
          else
            echo "ERROR: No .app found!"
            find ios/build -name "*.app" -type d
            exit 1
          fi

      - name: Upload iOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-simulator-${{ steps.version.outputs.filename }}
          path: artifacts/*-ios-simulator.zip
          retention-days: 30

