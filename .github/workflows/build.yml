name: Build iOS & Android

on:
  push:
    branches: [main]
    # Tags handled by release.yml (artifact promotion)
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      build_type:
        description: "Build type override"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - preview
          - production

env:
  NODE_VERSION: "20"

jobs:
  # ============================================
  # Parallel Tests (HIGH IMPACT: ~2-3 min faster)
  # ============================================
  test:
    name: Test (${{ matrix.name }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: typescript
            cmd: npx tsc --noEmit
          - name: format
            cmd: npm run format:check
          - name: jest
            cmd: npm test -- --maxWorkers=2
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Run ${{ matrix.name }}
        run: ${{ matrix.cmd }}

  # ============================================
  # Verify Signing Keys (fail fast)
  # ============================================
  verify-signing:
    name: Verify Signing Keys
    runs-on: ubuntu-latest
    steps:
      - name: Verify Android signing
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          EXPECTED_SHA1: "0D:54:88:9C:F2:AF:55:09:8F:40:35:E8:54:66:17:F8:30:FD:0D:86"
        run: |
          echo "=== Verifying Android signing configuration ==="

          # Verify all required secrets are set
          MISSING=""
          [ -z "$ANDROID_KEYSTORE_BASE64" ] && MISSING="$MISSING ANDROID_KEYSTORE_BASE64"
          [ -z "$ANDROID_KEYSTORE_PASSWORD" ] && MISSING="$MISSING ANDROID_KEYSTORE_PASSWORD"
          [ -z "$ANDROID_KEY_ALIAS" ] && MISSING="$MISSING ANDROID_KEY_ALIAS"
          [ -z "$ANDROID_KEY_PASSWORD" ] && MISSING="$MISSING ANDROID_KEY_PASSWORD"

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required secrets:$MISSING"
            exit 1
          fi

          # Decode keystore and verify fingerprint
          echo "$ANDROID_KEYSTORE_BASE64" | tr -d ' \n\r\t' | base64 -d > /tmp/release.keystore

          if [ ! -f /tmp/release.keystore ]; then
            echo "::error::Failed to decode keystore"
            exit 1
          fi

          SIZE=$(stat -c%s /tmp/release.keystore 2>/dev/null || stat -f%z /tmp/release.keystore)
          echo "Keystore file size: $SIZE bytes"

          if [ "$SIZE" -lt 1000 ]; then
            echo "::error::Keystore file too small ($SIZE bytes) - likely corrupted base64"
            exit 1
          fi

          # Verify fingerprint
          KEYTOOL_OUTPUT=$(keytool -list -v -keystore /tmp/release.keystore -storepass "$ANDROID_KEYSTORE_PASSWORD" 2>&1) || {
            echo "::error::keytool failed - wrong password or corrupted keystore"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          }

          ACTUAL_SHA1=$(echo "$KEYTOOL_OUTPUT" | grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')
          echo "Expected SHA1: $EXPECTED_SHA1"
          echo "Actual SHA1:   $ACTUAL_SHA1"

          if [ -z "$ACTUAL_SHA1" ]; then
            echo "::error::Could not extract SHA1 from keytool output"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          fi

          if [ "$ACTUAL_SHA1" != "$EXPECTED_SHA1" ]; then
            echo "::error::Keystore fingerprint mismatch! Expected Play Store upload key."
            exit 1
          fi

          echo "✅ Android signing verified"
          rm /tmp/release.keystore

      # TODO: Add iOS signing verification here later

  # ============================================
  # Build Rust libraries for Android (parallel)
  # ============================================
  rust-build-android:
    name: Rust - Android ${{ matrix.arch }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - arch: arm64-v8a
            rust_target: aarch64-linux-android
            abi: arm64-v8a
          - arch: armeabi-v7a
            rust_target: armv7-linux-androideabi
            abi: armeabi-v7a
          - arch: x86_64
            rust_target: x86_64-linux-android
            abi: x86_64
          - arch: x86
            rust_target: i686-linux-android
            abi: x86
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Rust Android target
        run: rustup target add ${{ matrix.rust_target }}

      - name: Restore cargo-ndk cache
        id: cache-cargo-ndk
        uses: actions/cache/restore@v4
        with:
          path: ~/.cargo/bin/cargo-ndk
          key: cargo-ndk-${{ runner.os }}-v3

      - name: Install cargo-ndk
        if: steps.cache-cargo-ndk.outputs.cache-hit != 'true'
        run: cargo install cargo-ndk

      - name: Save cargo-ndk cache
        if: steps.cache-cargo-ndk.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ~/.cargo/bin/cargo-ndk
          key: cargo-ndk-${{ runner.os }}-v3

      # Use swatinem/rust-cache - handles timestamps and fingerprints correctly
      - name: Setup Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: rust/route-matcher -> target
          prefix-key: rust-android-${{ matrix.arch }}
          # Cache is shared across builds with same Cargo.lock
          shared-key: ${{ matrix.rust_target }}
          # Save even on failure (partial builds can be reused)
          cache-on-failure: true

      - name: Build Rust library for ${{ matrix.arch }}
        working-directory: rust/route-matcher
        run: |
          cargo ndk -t ${{ matrix.rust_target }} build --release --features full

      - name: Build uniffi-bindgen (arm64 only)
        if: matrix.arch == 'arm64-v8a'
        working-directory: rust/route-matcher
        run: |
          cargo build --release --bin uniffi-bindgen --features ffi

      - name: Prepare artifact
        run: |
          mkdir -p artifact/${{ matrix.abi }}
          cp rust/route-matcher/target/${{ matrix.rust_target }}/release/libroute_matcher.so \
            artifact/${{ matrix.abi }}/libroute_matcher.so

      - name: Generate Kotlin bindings (arm64 only)
        if: matrix.arch == 'arm64-v8a'
        working-directory: rust/route-matcher
        run: |
          set -x  # Echo commands for debugging

          # Create artifact directory at repo root
          # From rust/route-matcher, need ../../ to reach repo root (up to rust/, then up to root)
          mkdir -p ../../artifact/kotlin

          echo ""
          echo "=== Running uniffi-bindgen ==="
          echo "Library: target/${{ matrix.rust_target }}/release/libroute_matcher.so"
          echo "Output directory: ../../artifact/kotlin"
          echo "Working directory: $(pwd)"
          echo ""

          # Run uniffi-bindgen from this directory (where Cargo.toml is)
          ./target/release/uniffi-bindgen generate \
            --library target/${{ matrix.rust_target }}/release/libroute_matcher.so \
            --language kotlin \
            --out-dir ../../artifact/kotlin 2>&1 || {
            echo ""
            echo "ERROR: uniffi-bindgen failed!"
            exit 1
          }

          echo ""
          echo "=== uniffi-bindgen succeeded! ==="
          echo "Contents of artifact directory:"
          ls -la ../../artifact/ || echo "artifact directory not found"
          echo ""
          echo "Contents of kotlin directory:"
          ls -la ../../artifact/kotlin/ || echo "kotlin directory not found"
          echo ""
          find ../../artifact/kotlin -type f 2>/dev/null || echo "No files found in kotlin directory"
          echo "==========================="

      - name: Upload .so file
        uses: actions/upload-artifact@v4
        with:
          name: rust-android-${{ matrix.arch }}
          path: artifact/${{ matrix.abi }}/
          retention-days: 1
          if-no-files-found: error

      - name: Debug Kotlin bindings location
        if: matrix.arch == 'arm64-v8a'
        run: |
          echo "=== Checking for Kotlin bindings before upload ==="
          echo "Current directory: $(pwd)"
          echo ""
          echo "Full listing of artifact directory:"
          find artifact -type d
          echo ""
          echo "All files in artifact:"
          find artifact -type f
          echo ""
          if [ -d "artifact/kotlin" ]; then
            echo "kotlin directory EXISTS!"
            ls -laR artifact/kotlin/
          else
            echo "kotlin directory DOES NOT EXIST"
            # Try to find if files were created elsewhere
            echo "Searching for .kt files in entire repo:"
            find . -name "route_matcher.kt" 2>/dev/null || echo "Not found"
          fi
          echo "======================================================"

      - name: Upload Kotlin bindings
        if: matrix.arch == 'arm64-v8a'
        uses: actions/upload-artifact@v4
        with:
          name: rust-android-kotlin-bindings
          path: artifact/kotlin/
          retention-days: 1
          if-no-files-found: error

  # ============================================
  # Build Android
  # ============================================
  build-android:
    name: Build Android APK
    needs: [test, verify-signing, rust-build-android]
    runs-on: ubuntu-latest
    env:
      # Fix Maven Central 403 errors by setting User-Agent header
      # JAVA_TOOL_OPTIONS affects all JVM processes including Gradle daemon and forks
      JAVA_TOOL_OPTIONS: "-Dhttp.agent=Gradle -Dhttps.agent=Gradle"
      GRADLE_OPTS: "-Dhttp.agent=Gradle -Dhttps.agent=Gradle"
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_code: ${{ steps.version.outputs.version_code }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      filename: ${{ steps.version.outputs.filename }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          BUILD_TYPE="preview"
          IS_RELEASE="false"

          if [[ "${{ inputs.build_type }}" != "" && "${{ inputs.build_type }}" != "auto" ]]; then
            BUILD_TYPE="${{ inputs.build_type }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            BUILD_TYPE="production"
            IS_RELEASE="true"
          fi

          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "production" ]]; then
            echo "filename=veloq-${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "filename=veloq-${VERSION}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "Build type: $BUILD_TYPE | Version: $VERSION ($VERSION_CODE)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # Use official Gradle action for better dependency caching
      # This reduces Maven Central requests and helps avoid IP blocking
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-read-only: false
          gradle-home-cache-includes: |
            caches
            notifications
            wrapper

      - name: Cache Android build outputs
        uses: actions/cache@v4
        with:
          path: |
            android/.gradle
            android/app/build
            android/build
          key: android-build-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            android-build-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Download arm64-v8a artifact
        uses: actions/download-artifact@v4
        with:
          name: rust-android-arm64-v8a
          path: artifacts/rust/arm64-v8a

      - name: Download armeabi-v7a artifact
        uses: actions/download-artifact@v4
        with:
          name: rust-android-armeabi-v7a
          path: artifacts/rust/armeabi-v7a

      - name: Download x86_64 artifact
        uses: actions/download-artifact@v4
        with:
          name: rust-android-x86_64
          path: artifacts/rust/x86_64

      - name: Download x86 artifact
        uses: actions/download-artifact@v4
        with:
          name: rust-android-x86
          path: artifacts/rust/x86

      - name: Download Kotlin bindings
        uses: actions/download-artifact@v4
        with:
          name: rust-android-kotlin-bindings
          path: artifacts/rust/kotlin

      - name: Debug downloaded artifacts
        run: |
          echo "=== Working directory ==="
          pwd
          echo ""
          echo "=== Downloaded artifacts structure ==="
          find artifacts/rust -type f -exec ls -lh {} \;
          echo "====================================="

      - name: Install Rust libraries to native module
        run: |
          echo "=== Install Rust libraries - Starting ==="
          echo "Current directory: $(pwd)"

          # Debug: show what was actually downloaded
          echo ""
          echo "=== Contents of artifacts/rust ==="
          ls -la artifacts/rust/
          echo ""

          # Copy downloaded .so files to jniLibs
          mkdir -p modules/route-matcher-native/android/src/main/jniLibs/{arm64-v8a,armeabi-v7a,x86_64,x86}

          echo "=== Starting .so file copy ==="
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            echo "Processing $arch..."
            # Try multiple possible paths
            so_file=""
            for path in \
              "artifacts/rust/$arch/libroute_matcher.so" \
              "artifacts/rust/$arch/$arch/libroute_matcher.so"
            do
              if [ -f "$path" ]; then
                so_file="$path"
                echo "  Found at: $path"
                break
              fi
            done

            if [ -z "$so_file" ]; then
              # Try searching
              echo "  Not found at expected paths, searching..."
              found=$(find artifacts/rust -name "libroute_matcher.so" 2>/dev/null | head -1)
              if [ -n "$found" ]; then
                so_file="$found"
                echo "  Found via search: $found"
              fi
            fi

            if [ -n "$so_file" ]; then
              cp "$so_file" "modules/route-matcher-native/android/src/main/jniLibs/$arch/libroute_matcher.so"
              echo "  ✓ Copied to jniLibs/$arch/"
            else
              echo "  ✗ ERROR: No .so file found for $arch!"
              echo ""
              echo "All .so files in artifacts/rust:"
              find artifacts/rust -name "*.so" -exec ls -lh {} \; 2>/dev/null || echo "None found"
              exit 1
            fi
          done

          # Copy Kotlin bindings
          echo "=== Copying Kotlin bindings ==="
          mkdir -p modules/route-matcher-native/android/src/main/java/com/veloq/route

          # Check if kotlin directory exists
          if [ -d "artifacts/rust/kotlin" ]; then
            echo "Found kotlin directory, copying files:"
            ls -la artifacts/rust/kotlin/
            cp artifacts/rust/kotlin/*.kt modules/route-matcher-native/android/src/main/java/com/veloq/route/ 2>/dev/null || echo "  No .kt files in kotlin directory"
          fi

          # Also search for any .kt files in artifacts/rust (fallback)
          kt_files=$(find artifacts/rust -type f -name "*.kt" 2>/dev/null)
          if [ -n "$kt_files" ]; then
            echo "Found .kt files via search:"
            echo "$kt_files"
            echo "$kt_files" | while read kt; do
              echo "  Copying $kt"
              cp "$kt" modules/route-matcher-native/android/src/main/java/com/veloq/route/
            done
          else
            echo "  WARNING: No .kt files found in artifacts/rust"
          fi

          # Validation: verify all .so files exist and have content
          echo "=== Validating copied .so files ==="
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            so_file="modules/route-matcher-native/android/src/main/jniLibs/$arch/libroute_matcher.so"
            if [ -f "$so_file" ]; then
              size=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null || echo "0")
              if [ "$size" -gt 0 ]; then
                echo "✓ $arch: $so_file (${size} bytes)"
              else
                echo "✗ $arch: $so_file exists but is empty!"
                exit 1
              fi
            else
              echo "✗ $arch: $so_file not found!"
              exit 1
            fi
          done

          # Show final jniLibs structure
          echo "=== Final jniLibs structure ==="
          find modules/route-matcher-native/android/src/main/jniLibs -type f -exec ls -lh {} \;
          echo "================================"

          # Show Kotlin bindings
          echo "=== Kotlin bindings ==="
          if [ -d "modules/route-matcher-native/android/src/main/java/com/veloq/route" ]; then
            ls -la modules/route-matcher-native/android/src/main/java/com/veloq/route/*.kt 2>/dev/null || echo "No .kt files found"
          else
            echo "Kotlin bindings directory not found"
          fi
          echo "========================"

      - name: Cache Android prebuild
        id: android-prebuild-cache
        uses: actions/cache@v4
        with:
          path: android
          key: android-prebuild-${{ runner.os }}-${{ hashFiles('app.json', 'package.json', 'package-lock.json', 'plugins/**', 'expo-modules/**/*.json', 'modules/**/android/**', 'rust/route-matcher/Cargo.toml', 'rust/route-matcher/**/*.rs', 'node_modules/react-native-vector-icons/package.json', 'node_modules/react-native-webview/package.json') }}
          restore-keys: |
            android-prebuild-${{ runner.os }}-

      - name: Generate Android native project
        if: steps.android-prebuild-cache.outputs.cache-hit != 'true'
        run: npx expo prebuild --platform android

      # Create Gradle init script to fix Maven Central 403 errors
      # Forces all Maven Central requests through repo1.maven.org mirror
      - name: Create Gradle init script for CI
        run: |
          mkdir -p ~/.gradle
          echo "ZGVmIHJlcG9VcmwgPSAiaHR0cHM6Ly9yZXBvMS5tYXZlbi5vcmcvbWF2ZW4yLyIKCmJlZm9yZVNldHRpbmdzIHsgc2V0dGluZ3MgLT4KICBzZXR0aW5ncy5wbHVnaW5NYW5hZ2VtZW50IHsKICAgIHJlcG9zaXRvcmllcyB7CiAgICAgIG1hdmVuIHsgdXJsID0gdXJpKHJlcG9VcmwpOyBuYW1lID0gIk1hdmVuQ2VudHJhbE1pcnJvciIgfQogICAgICBncmFkbGVQbHVnaW5Qb3J0YWwoKQogICAgICBnb29nbGUoKQogICAgfQogIH0KfQoKc2V0dGluZ3NFdmFsdWF0ZWQgeyBzZXR0aW5ncyAtPgogIHNldHRpbmdzLnBsdWdpbk1hbmFnZW1lbnQgewogICAgcmVwb3NpdG9yaWVzIHsKICAgICAgY2xlYXIoKQogICAgICBtYXZlbiB7IHVybCA9IHVyaShyZXBvVXJsKTsgbmFtZSA9ICJNYXZlbkNlbnRyYWxNaXJyb3IiIH0KICAgICAgZ3JhZGxlUGx1Z2luUG9ydGFsKCkKICAgICAgZ29vZ2xlKCkKICAgIH0KICB9Cn0KCmFsbHByb2plY3RzIHsKICBidWlsZHNjcmlwdCB7CiAgICByZXBvc2l0b3JpZXMgewogICAgICBtYXZlbiB7IHVybCA9IHVyaShyZXBvVXJsKTsgbmFtZSA9ICJNYXZlbkNlbnRyYWxNaXJyb3IiIH0KICAgICAgZ29vZ2xlKCkKICAgIH0KICB9CiAgcmVwb3NpdG9yaWVzIHsKICAgIG1hdmVuIHsgdXJsID0gdXJpKHJlcG9VcmwpOyBuYW1lID0gIk1hdmVuQ2VudHJhbE1pcnJvciIgfQogICAgZ29vZ2xlKCkKICB9Cn0K" | base64 -d > ~/.gradle/init.gradle
          echo "=== init.gradle contents ==="
          cat ~/.gradle/init.gradle

      # Setup signing AFTER prebuild creates android/ directory
      - name: Setup signing
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          # Keystore was already verified earlier - just decode to final location
          mkdir -p android/app
          echo "$ANDROID_KEYSTORE_BASE64" | tr -d ' \n\r\t' | base64 -d > android/app/release.keystore

          # Create keystore.properties
          printf '%s\n' \
            "storeFile=release.keystore" \
            "storePassword=$ANDROID_KEYSTORE_PASSWORD" \
            "keyAlias=$ANDROID_KEY_ALIAS" \
            "keyPassword=$ANDROID_KEY_PASSWORD" \
            > android/keystore.properties

          echo "✅ Signing configured"

      - name: Verify Rust libraries before build
        run: |
          echo "=== Verifying .so files before Gradle build ==="

          # Check if jniLibs directory exists
          if [ ! -d "modules/route-matcher-native/android/src/main/jniLibs" ]; then
            echo "ERROR: jniLibs directory not found!"
            echo "Checking parent directories:"
            ls -la modules/route-matcher-native/android/ 2>/dev/null || echo "android/ directory not found"
            exit 1
          fi

          # Show full jniLibs structure
          echo "jniLibs directory structure:"
          find modules/route-matcher-native/android/src/main/jniLibs -type f -exec ls -lh {} \; || echo "No files found in jniLibs"
          echo ""

          # Verify each architecture
          all_ok=true
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            so_file="modules/route-matcher-native/android/src/main/jniLibs/$arch/libroute_matcher.so"
            if [ -f "$so_file" ]; then
              size=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null || echo "0")
              md5sum=$(md5sum "$so_file" 2>/dev/null | cut -d' ' -f1 || echo "N/A")
              if [ "$size" -gt 0 ]; then
                echo "✓ $arch: ${size} bytes (md5: $md5sum)"
              else
                echo "✗ $arch: FILE EXISTS BUT IS EMPTY!"
                all_ok=false
              fi
            else
              echo "✗ $arch: FILE NOT FOUND at $so_file"
              all_ok=false
            fi
          done

          # Show Kotlin bindings if present
          echo ""
          if [ -d "modules/route-matcher-native/android/src/main/java/com/veloq/route" ]; then
            echo "Kotlin bindings found:"
            ls -la modules/route-matcher-native/android/src/main/java/com/veloq/route/*.kt 2>/dev/null || echo "  No .kt files"
          else
            echo "WARNING: Kotlin bindings directory not found"
          fi

          if [ "$all_ok" = "false" ]; then
            echo ""
            echo "ERROR: Some .so files are missing or empty!"
            exit 1
          fi

          echo "=================================================="
          echo "All Rust libraries verified successfully!"

      - name: Build Android APK
        env:
          RUST_PREBUILT: "true"
        run: |
          cd android && ./gradlew assembleRelease --no-daemon

      - name: Copy APK
        run: |
          mkdir -p artifacts
          if [ ! -f android/keystore.properties ]; then
            echo "::error::keystore.properties not found - release builds must be signed"
            exit 1
          fi
          echo "✅ APK signed with release keystore"
          cp android/app/build/outputs/apk/release/app-release.apk \
            "artifacts/${{ steps.version.outputs.filename }}.apk"

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-apk-${{ steps.version.outputs.filename }}
          path: artifacts/*.apk
          retention-days: 30

      - name: Build AAB for Play Store
        # Build AAB on main branch (needed for release artifact promotion)
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        env:
          RUST_PREBUILT: "true"
        run: |
          # Android folder and dependencies are already set up from APK build
          # Just run Gradle to build the AAB
          cd android && ./gradlew bundleRelease --no-daemon

      - name: Rename AAB
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: |
          AAB_PATH=$(find android/app/build/outputs/bundle -name "*.aab" | head -1)
          if [ -n "$AAB_PATH" ]; then
            cp "$AAB_PATH" "artifacts/${{ steps.version.outputs.filename }}.aab"
          fi

      - name: Upload AAB artifact
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: android-aab-${{ steps.version.outputs.filename }}
          path: artifacts/*.aab
          retention-days: 30

  # ============================================
  # Build iOS
  # ============================================
  build-ios:
    name: Build iOS App
    needs: test
    runs-on: macos-15
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_code: ${{ steps.version.outputs.version_code }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      filename: ${{ steps.version.outputs.filename }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          BUILD_TYPE="preview"
          IS_RELEASE="false"

          if [[ "${{ inputs.build_type }}" != "" && "${{ inputs.build_type }}" != "auto" ]]; then
            BUILD_TYPE="${{ inputs.build_type }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            BUILD_TYPE="production"
            IS_RELEASE="true"
          fi

          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "production" ]]; then
            echo "filename=veloq-${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "filename=veloq-${VERSION}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "Build type: $BUILD_TYPE | Version: $VERSION ($VERSION_CODE)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      # ============================================
      # Rust Build
      # ============================================
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Rust iOS targets
        run: rustup target add aarch64-apple-ios aarch64-apple-ios-sim x86_64-apple-ios

      # Use swatinem/rust-cache - handles timestamps and fingerprints correctly
      - name: Setup Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: rust/route-matcher -> target
          prefix-key: rust-ios
          # Save even on failure (partial builds can be reused)
          cache-on-failure: true

      - name: Build Rust library for iOS
        run: |
          cd rust/route-matcher
          ./scripts/build-ios.sh

      - name: Install Rust library to native module
        run: |
          cd rust/route-matcher
          ./scripts/install-ios.sh

      - name: Cache iOS prebuild
        id: ios-prebuild-cache
        uses: actions/cache@v4
        with:
          path: ios
          key: ios-prebuild-${{ runner.os }}-${{ hashFiles('app.json', 'package.json', 'plugins/**', 'expo-modules/**/*.json', 'modules/**/ios/**', 'rust/route-matcher/Cargo.toml', 'rust/route-matcher/**/*.rs') }}
          restore-keys: |
            ios-prebuild-${{ runner.os }}-

      # ============================================
      # iOS Build
      # ============================================
      - name: Install dependencies
        run: npm ci

      - name: Generate native project
        if: steps.ios-prebuild-cache.outputs.cache-hit != 'true'
        run: npx expo prebuild --platform ios

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ios/Pods
            ~/Library/Caches/CocoaPods
          key: cocoapods-${{ runner.os }}-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            cocoapods-${{ runner.os }}-

      - name: Setup Ruby & Install CocoaPods
        if: steps.ios-prebuild-cache.outputs.cache-hit != 'true'
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: Install Pods
        if: steps.ios-prebuild-cache.outputs.cache-hit != 'true'
        working-directory: ios
        run: pod install

      - name: Build iOS Simulator app
        run: |
          xcodebuild -workspace ios/veloq.xcworkspace \
            -scheme Veloq \
            -configuration Release \
            -sdk iphonesimulator \
            -arch x86_64 \
            -derivedDataPath ios/build \
            CODE_SIGNING_ALLOWED=NO \
            2>&1 | tee build.log || (echo "=== Build failed, showing last 100 lines ===" && tail -100 build.log && exit 1)

      - name: Package .app
        run: |
          mkdir -p artifacts
          APP_PATH=$(find ios/build/Build/Products/Release-iphonesimulator -name "*.app" -type d | head -1)
          if [ -n "$APP_PATH" ]; then
            cd "$(dirname "$APP_PATH")"
            zip -r "$GITHUB_WORKSPACE/artifacts/${{ steps.version.outputs.filename }}-ios-simulator.zip" "$(basename "$APP_PATH")"
          else
            echo "ERROR: No .app found!"
            find ios/build -name "*.app" -type d
            exit 1
          fi

      - name: Upload iOS artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-simulator-${{ steps.version.outputs.filename }}
          path: artifacts/*-ios-simulator.zip
          retention-days: 30

      - name: Upload Rust build artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: rust-ios-build-artifacts
          path: |
            rust/route-matcher/target/ios/
            modules/route-matcher-native/ios/Frameworks/
            modules/route-matcher-native/ios/Generated/
          retention-days: 7