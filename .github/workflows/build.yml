name: Build iOS & Android

on:
  push:
    branches: [main]
    # Tags handled by release.yml (artifact promotion)
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      build_type:
        description: "Build type override"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - preview
          - production

env:
  NODE_VERSION: "20"

jobs:
  # ============================================
  # Parallel Tests (HIGH IMPACT: ~2-3 min faster)
  # ============================================
  test:
    name: Test (${{ matrix.name }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: typescript
            cmd: npx tsc --noEmit
          - name: format
            cmd: npm run format:check
          - name: jest
            cmd: npm test -- --maxWorkers=2
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: ${{ matrix.name == 'typescript' && 'recursive' || 'false' }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      # TypeScript check requires generated bindings from Rust
      - name: Setup Rust
        if: matrix.name == 'typescript'
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust
        if: matrix.name == 'typescript'
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: modules/veloqrs/rust
          key: typecheck

      - name: Build Rust and generate bindings
        if: matrix.name == 'typescript'
        working-directory: modules/veloqrs/rust
        run: |
          cargo build --release -p veloqrs
          npx uniffi-bindgen-react-native generate jsi bindings \
            --ts-dir ../src/generated \
            --cpp-dir ../cpp/generated \
            --library \
            target/release/libveloqrs.so

      - name: Run ${{ matrix.name }}
        run: ${{ matrix.cmd }}

  # ============================================
  # Verify Signing Keys (fail fast)
  # ============================================
  verify-signing:
    name: Verify Signing (${{ matrix.platform }})
    runs-on: ${{ matrix.runs-on }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: android
            runs-on: ubuntu-latest
          - platform: ios
            runs-on: macos-26
    steps:
      # ---- Android Signing Verification ----
      - name: Verify Android signing
        if: matrix.platform == 'android'
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          EXPECTED_SHA1: "0D:54:88:9C:F2:AF:55:09:8F:40:35:E8:54:66:17:F8:30:FD:0D:86"
        run: |
          echo "=== Verifying Android signing configuration ==="

          # Verify all required secrets are set
          MISSING=""
          [ -z "$ANDROID_KEYSTORE_BASE64" ] && MISSING="$MISSING ANDROID_KEYSTORE_BASE64"
          [ -z "$ANDROID_KEYSTORE_PASSWORD" ] && MISSING="$MISSING ANDROID_KEYSTORE_PASSWORD"
          [ -z "$ANDROID_KEY_ALIAS" ] && MISSING="$MISSING ANDROID_KEY_ALIAS"
          [ -z "$ANDROID_KEY_PASSWORD" ] && MISSING="$MISSING ANDROID_KEY_PASSWORD"

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required secrets:$MISSING"
            exit 1
          fi

          # Decode keystore and verify fingerprint
          echo "$ANDROID_KEYSTORE_BASE64" | tr -d ' \n\r\t' | base64 -d > /tmp/release.keystore

          if [ ! -f /tmp/release.keystore ]; then
            echo "::error::Failed to decode keystore"
            exit 1
          fi

          SIZE=$(stat -c%s /tmp/release.keystore 2>/dev/null || stat -f%z /tmp/release.keystore)
          echo "Keystore file size: $SIZE bytes"

          if [ "$SIZE" -lt 1000 ]; then
            echo "::error::Keystore file too small ($SIZE bytes) - likely corrupted base64"
            exit 1
          fi

          # Verify fingerprint
          KEYTOOL_OUTPUT=$(keytool -list -v -keystore /tmp/release.keystore -storepass "$ANDROID_KEYSTORE_PASSWORD" 2>&1) || {
            echo "::error::keytool failed - wrong password or corrupted keystore"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          }

          ACTUAL_SHA1=$(echo "$KEYTOOL_OUTPUT" | grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')
          echo "Expected SHA1: $EXPECTED_SHA1"
          echo "Actual SHA1:   $ACTUAL_SHA1"

          if [ -z "$ACTUAL_SHA1" ]; then
            echo "::error::Could not extract SHA1 from keytool output"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          fi

          if [ "$ACTUAL_SHA1" != "$EXPECTED_SHA1" ]; then
            echo "::error::Keystore fingerprint mismatch! Expected Play Store upload key."
            exit 1
          fi

          echo "âœ… Android signing verified"
          rm /tmp/release.keystore

      # ---- iOS Signing Verification (main branch only) ----
      - name: Checkout repository
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: actions/checkout@v4

      - name: Check iOS signing secrets
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_SSH_PRIVATE_KEY: ${{ secrets.MATCH_SSH_PRIVATE_KEY }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_API_KEY: ${{ secrets.ASC_API_KEY }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
          IOS_DISTRIBUTION_CERT_P12: ${{ secrets.IOS_DISTRIBUTION_CERT_P12 }}
          IOS_DISTRIBUTION_CERT_PASSWORD: ${{ secrets.IOS_DISTRIBUTION_CERT_PASSWORD }}
        run: |
          echo "=== Verifying iOS signing configuration ==="

          missing=()
          [ -z "$MATCH_GIT_URL" ] && missing+=("MATCH_GIT_URL")
          [ -z "$MATCH_PASSWORD" ] && missing+=("MATCH_PASSWORD")
          [ -z "$MATCH_SSH_PRIVATE_KEY" ] && missing+=("MATCH_SSH_PRIVATE_KEY")
          [ -z "$ASC_KEY_ID" ] && missing+=("ASC_KEY_ID")
          [ -z "$ASC_ISSUER_ID" ] && missing+=("ASC_ISSUER_ID")
          [ -z "$ASC_API_KEY" ] && missing+=("ASC_API_KEY")
          [ -z "$FASTLANE_TEAM_ID" ] && missing+=("FASTLANE_TEAM_ID")
          [ -z "$IOS_DISTRIBUTION_CERT_P12" ] && missing+=("IOS_DISTRIBUTION_CERT_P12")
          [ -z "$IOS_DISTRIBUTION_CERT_PASSWORD" ] && missing+=("IOS_DISTRIBUTION_CERT_PASSWORD")

          if [ ${#missing[@]} -gt 0 ]; then
            echo "::error::Missing iOS signing secrets: ${missing[*]}"
            exit 1
          fi

          echo "âœ… All iOS signing secrets configured"

      - name: Verify p12 certificate
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          IOS_DISTRIBUTION_CERT_P12: ${{ secrets.IOS_DISTRIBUTION_CERT_P12 }}
          IOS_DISTRIBUTION_CERT_PASSWORD: ${{ secrets.IOS_DISTRIBUTION_CERT_PASSWORD }}
        run: |
          echo "=== Verifying p12 certificate ==="

          # Verify base64 decodes to valid p12
          echo "$IOS_DISTRIBUTION_CERT_P12" | base64 -d > /tmp/test.p12 2>/dev/null || {
            echo "::error::IOS_DISTRIBUTION_CERT_P12 is not valid base64"
            exit 1
          }

          # Check file size (p12 should be at least a few KB)
          SIZE=$(stat -f%z /tmp/test.p12 2>/dev/null || stat -c%s /tmp/test.p12)
          echo "Certificate file size: $SIZE bytes"

          if [ "$SIZE" -lt 1000 ]; then
            echo "::error::p12 file too small ($SIZE bytes) - likely invalid"
            rm /tmp/test.p12
            exit 1
          fi

          # Try to read the p12 with the password
          openssl pkcs12 -in /tmp/test.p12 -nokeys -passin pass:"$IOS_DISTRIBUTION_CERT_PASSWORD" -info 2>&1 | head -5 || {
            echo "::error::Cannot read p12 file - password may be incorrect"
            rm /tmp/test.p12
            exit 1
          }

          rm /tmp/test.p12
          echo "âœ… p12 certificate and password verified"

      - name: Setup SSH for Match
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.MATCH_SSH_PRIVATE_KEY }}

      - name: Verify Match repository access
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
        run: |
          echo "=== Testing Match repository access ==="
          git ls-remote "$MATCH_GIT_URL" &>/dev/null || {
            echo "::error::Cannot access Match repository at $MATCH_GIT_URL"
            exit 1
          }
          echo "âœ… Match repository accessible"

      - name: Setup Ruby
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true
          working-directory: config/fastlane

      - name: Verify certificates via Match
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        working-directory: config/fastlane
        run: |
          echo "=== Syncing certificates from Match (readonly) ==="
          bundle exec fastlane match appstore --readonly --verbose

      - name: Check certificate expiration
        if: matrix.platform == 'ios' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          echo "=== Checking certificate expiration ==="

          # Find distribution certificate in keychain
          CERT_INFO=$(security find-certificate -c "Apple Distribution" -p login.keychain 2>/dev/null || \
                      security find-certificate -c "iPhone Distribution" -p login.keychain 2>/dev/null || true)

          if [ -z "$CERT_INFO" ]; then
            echo "::warning::Could not find distribution certificate in keychain"
            exit 0
          fi

          # Extract expiration date
          EXPIRY=$(echo "$CERT_INFO" | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          echo "ðŸ“œ Certificate expires: $EXPIRY"

          # Check if expiring within 30 days (2592000 seconds)
          if echo "$CERT_INFO" | openssl x509 -checkend 2592000 > /dev/null 2>&1; then
            echo "âœ… Certificate valid for 30+ days"
          else
            echo "::warning::âš ï¸ Certificate expires within 30 days! Consider renewing soon."
          fi

          # Check if expiring within 7 days (604800 seconds) - this is critical
          if ! echo "$CERT_INFO" | openssl x509 -checkend 604800 > /dev/null 2>&1; then
            echo "::error::Certificate expires within 7 days! Immediate action required."
            exit 1
          fi

          echo "âœ… iOS signing verification complete"

  # ============================================
  # Build Android
  # ============================================
  build-android:
    name: Build Android APK
    needs: [test, verify-signing]
    runs-on: ubuntu-latest
    env:
      # Fix Maven Central 403 errors by setting User-Agent header
      # JAVA_TOOL_OPTIONS affects all JVM processes including Gradle daemon and forks
      JAVA_TOOL_OPTIONS: "-Dhttp.agent=Gradle -Dhttps.agent=Gradle"
      GRADLE_OPTS: "-Dhttp.agent=Gradle -Dhttps.agent=Gradle"
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_code: ${{ steps.version.outputs.version_code }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      filename: ${{ steps.version.outputs.filename }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Get version info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          BUILD_TYPE="preview"
          IS_RELEASE="false"

          if [[ "${{ inputs.build_type }}" != "" && "${{ inputs.build_type }}" != "auto" ]]; then
            BUILD_TYPE="${{ inputs.build_type }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            BUILD_TYPE="production"
            IS_RELEASE="true"
          fi

          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "production" ]]; then
            echo "filename=veloq-${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "filename=veloq-${VERSION}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "Build type: $BUILD_TYPE | Version: $VERSION ($VERSION_CODE)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # Use official Gradle action for better dependency caching
      # This reduces Maven Central requests and helps avoid IP blocking
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-read-only: false
          gradle-home-cache-includes: |
            caches
            notifications
            wrapper

      - name: Cache Metro bundler
        uses: actions/cache@v4
        with:
          path: |
            /tmp/metro-*
            node_modules/.cache
          key: metro-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            metro-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-linux-android,armv7-linux-androideabi,x86_64-linux-android,i686-linux-android

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: modules/veloqrs/rust

      - name: Install cargo-ndk
        run: cargo install cargo-ndk

      # Build for host FIRST to generate bindings BEFORE cache restoration
      - name: Build Rust for host (binding generation)
        working-directory: modules/veloqrs/rust
        run: |
          # Build for Linux host to generate bindings
          cargo build --release -p veloqrs
          echo "âœ“ Built for host platform"

      - name: Generate UniFFI Bindings
        working-directory: modules/veloqrs/rust
        run: |
          # Generate TypeScript/C++ bindings from host library
          # This MUST happen BEFORE prebuild cache restoration and Gradle build
          npx uniffi-bindgen-react-native generate jsi bindings \
            --ts-dir ../src/generated \
            --cpp-dir ../cpp/generated \
            --library \
            target/release/libveloqrs.so
          echo "âœ“ Generated UniFFI bindings"

          # Generate turbo-module wrapper files (cpp/veloqrs.h, cpp/veloqrs.cpp)
          cd .. && npx uniffi-bindgen-react-native generate jsi turbo-module veloqrs
          echo "âœ“ Generated turbo-module wrapper"
          ls -la cpp/ cpp/generated/

      # Verify C++ files exist before proceeding (safety check)
      - name: Verify C++ bindings exist
        run: |
          echo "=== Verifying C++ bindings ==="
          MISSING=""
          [ ! -f "modules/veloqrs/cpp/veloqrs.h" ] && MISSING="$MISSING cpp/veloqrs.h"
          [ ! -f "modules/veloqrs/cpp/veloqrs.cpp" ] && MISSING="$MISSING cpp/veloqrs.cpp"
          [ ! -f "modules/veloqrs/cpp/generated/veloqrs.hpp" ] && MISSING="$MISSING cpp/generated/veloqrs.hpp"
          [ ! -f "modules/veloqrs/cpp/generated/veloqrs.cpp" ] && MISSING="$MISSING cpp/generated/veloqrs.cpp"
          if [ -n "$MISSING" ]; then
            echo "::error::Missing C++ files:$MISSING"
            echo "This indicates binding generation failed. Check the 'Generate UniFFI Bindings' step."
            exit 1
          fi
          echo "âœ“ All C++ bindings present"

      - name: Build Rust libraries for Android
        working-directory: modules/veloqrs/rust
        run: |
          echo "=== Building veloqrs for Android ==="
          mkdir -p ../android/src/main/jniLibs

          # Build for all Android architectures
          cargo ndk -t aarch64-linux-android -t armv7-linux-androideabi -t x86_64-linux-android -t i686-linux-android \
            --platform 24 -o ../android/src/main/jniLibs \
            build --release -p veloqrs

          # Verify installation
          echo "=== Verifying .so installation ==="
          find ../android/src/main/jniLibs -name "*.so" -exec ls -lh {} \;

      - name: Cache Android prebuild
        id: android-prebuild-cache
        uses: actions/cache@v4
        with:
          # Cache generated project files, but EXCLUDE build outputs to prevent stale .so conflicts
          path: |
            android
            !android/build
            !android/.gradle
            !android/.cxx
            !android/app/build
            !android/app/.cxx
          # v5: exclude build directories to prevent stale CMake outputs
          key: android-prebuild-v5-${{ runner.os }}-${{ hashFiles('app.json', 'package.json', 'package-lock.json', 'plugins/**', 'expo-modules/**/*.json', 'modules/**/android/**', 'modules/**/package.json', 'node_modules/react-native-vector-icons/package.json', 'node_modules/react-native-webview/package.json') }}

      - name: Generate Android native project
        if: steps.android-prebuild-cache.outputs.cache-hit != 'true'
        run: npx expo prebuild --platform android

      # Install Gradle init script to fix Maven Central 403 errors
      - name: Install Gradle init script
        run: |
          mkdir -p ~/.gradle
          cp .github/ci-init.gradle ~/.gradle/init.gradle

      # Setup signing AFTER prebuild creates android/ directory
      - name: Setup signing
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          # Keystore was already verified earlier - just decode to final location
          mkdir -p android/app
          echo "$ANDROID_KEYSTORE_BASE64" | tr -d ' \n\r\t' | base64 -d > android/app/release.keystore

          # Create keystore.properties
          printf '%s\n' \
            "storeFile=release.keystore" \
            "storePassword=$ANDROID_KEYSTORE_PASSWORD" \
            "keyAlias=$ANDROID_KEY_ALIAS" \
            "keyPassword=$ANDROID_KEY_PASSWORD" \
            > android/keystore.properties

          echo "âœ… Signing configured"

      - name: Verify veloqrs libraries before build
        run: |
          echo "=== Verifying .so files before Gradle build ==="

          # Check if jniLibs directory exists
          if [ ! -d "modules/veloqrs/android/src/main/jniLibs" ]; then
            echo "ERROR: jniLibs directory not found!"
            exit 1
          fi

          # Verify each architecture
          all_ok=true
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            so_file="modules/veloqrs/android/src/main/jniLibs/$arch/libveloqrs.so"
            if [ -f "$so_file" ]; then
              size=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null || echo "0")
              if [ "$size" -gt 0 ]; then
                echo "âœ“ $arch: ${size} bytes"
              else
                echo "âœ— $arch: FILE EXISTS BUT IS EMPTY!"
                all_ok=false
              fi
            else
              echo "âœ— $arch: FILE NOT FOUND at $so_file"
              all_ok=false
            fi
          done

          # Verify VeloqrsModule.kt (JNI-based TurboModule wrapper - committed in repo)
          # NOTE: We do NOT use veloqrs.kt from releases (that's JNA-based, JVM-only)
          VELOQ_MODULE="modules/veloqrs/android/src/main/java/com/veloq/VeloqrsModule.kt"
          if [ -f "$VELOQ_MODULE" ]; then
            echo "âœ“ VeloqrsModule.kt (JNI): $VELOQ_MODULE"
          else
            echo "âœ— VeloqrsModule.kt not found - this should be committed in the repo"
            all_ok=false
          fi

          if [ "$all_ok" = "false" ]; then
            echo "ERROR: veloqrs libraries verification failed!"
            exit 1
          fi

          echo "âœ… All veloqrs libraries verified!"

      - name: Clean stale dex archives
        run: |
          # Remove dex archives that can become stale when npm dependencies change
          rm -rf android/app/build/intermediates/project_dex_archive
          rm -rf android/app/build/intermediates/dex
          echo "âœ… Cleaned dex archives"

      - name: Build Android APK
        if: github.ref != 'refs/heads/main' && github.event_name != 'workflow_dispatch'
        run: cd android && ./gradlew assembleRelease --no-daemon --no-build-cache

      - name: Build Android APK + AAB
        # Build both in single Gradle invocation on main (faster than separate builds)
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: cd android && ./gradlew assembleRelease bundleRelease --no-daemon --no-build-cache

      - name: Copy APK
        run: |
          mkdir -p artifacts
          if [ ! -f android/keystore.properties ]; then
            echo "::error::keystore.properties not found - release builds must be signed"
            exit 1
          fi
          cp android/app/build/outputs/apk/release/app-release.apk \
            "artifacts/${{ steps.version.outputs.filename }}.apk"

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-apk-${{ steps.version.outputs.filename }}
          path: artifacts/*.apk
          retention-days: 30

      - name: Rename AAB
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: |
          AAB_PATH=$(find android/app/build/outputs/bundle -name "*.aab" | head -1)
          if [ -n "$AAB_PATH" ]; then
            cp "$AAB_PATH" "artifacts/${{ steps.version.outputs.filename }}.aab"
          fi

      - name: Upload AAB artifact
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: android-aab-${{ steps.version.outputs.filename }}
          path: artifacts/*.aab
          retention-days: 30

      - name: Verify AAB signing
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        env:
          EXPECTED_SHA1: "0D:54:88:9C:F2:AF:55:09:8F:40:35:E8:54:66:17:F8:30:FD:0D:86"
        run: |
          echo "=== Verifying AAB was signed with correct key ==="
          AAB_FILE="artifacts/${{ steps.version.outputs.filename }}.aab"

          if [ ! -f "$AAB_FILE" ]; then
            echo "::error::AAB file not found at $AAB_FILE"
            exit 1
          fi

          # AABs use JAR signing (v1) so we can extract from META-INF
          # Unlike APKs, AABs don't support v2/v3 signature schemes
          ACTUAL_SHA1=$(unzip -p "$AAB_FILE" "META-INF/BNDLTOOL.RSA" 2>/dev/null | \
            keytool -printcert 2>/dev/null | \
            grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')

          # Fallback: try any .RSA file if BNDLTOOL.RSA doesn't exist
          if [ -z "$ACTUAL_SHA1" ]; then
            RSA_FILE=$(unzip -l "$AAB_FILE" 2>/dev/null | grep "META-INF/.*\.RSA" | awk '{print $4}' | head -1)
            if [ -n "$RSA_FILE" ]; then
              ACTUAL_SHA1=$(unzip -p "$AAB_FILE" "$RSA_FILE" 2>/dev/null | \
                keytool -printcert 2>/dev/null | \
                grep "SHA1:" | head -1 | sed 's/.*SHA1: *//' | tr -d ' ')
            fi
          fi

          echo "Expected SHA1: $EXPECTED_SHA1"
          echo "Actual SHA1:   $ACTUAL_SHA1"

          if [ -z "$ACTUAL_SHA1" ]; then
            echo "::error::Could not extract signing certificate from AAB"
            echo "AAB contents:"
            unzip -l "$AAB_FILE" | grep -i "meta-inf" || echo "No META-INF found"
            exit 1
          fi

          if [ "$ACTUAL_SHA1" != "$EXPECTED_SHA1" ]; then
            echo "::error::AAB signed with WRONG KEY!"
            echo "::error::Expected Play Store upload key but got different certificate"
            exit 1
          fi

          echo "âœ… AAB signed with correct release key"

  # ============================================
  # Build iOS
  # ============================================
  build-ios:
    name: Build iOS App
    needs: [test, verify-signing]
    runs-on: macos-26
    timeout-minutes: 90
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_code: ${{ steps.version.outputs.version_code }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      filename: ${{ steps.version.outputs.filename }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '26.2'

      - name: Get version info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT

          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          BUILD_TYPE="preview"
          IS_RELEASE="false"

          if [[ "${{ inputs.build_type }}" != "" && "${{ inputs.build_type }}" != "auto" ]]; then
            BUILD_TYPE="${{ inputs.build_type }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            BUILD_TYPE="production"
            IS_RELEASE="true"
          fi

          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "production" ]]; then
            echo "filename=veloq-${VERSION}" >> $GITHUB_OUTPUT
          else
            echo "filename=veloq-${VERSION}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi

          echo "Build type: $BUILD_TYPE | Version: $VERSION ($VERSION_CODE)"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "${{ env.NODE_VERSION }}"
          cache: "npm"

      # ============================================
      # Build Rust libraries for iOS
      # ============================================
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios,aarch64-apple-ios-sim,x86_64-apple-ios

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: modules/veloqrs/rust

      - name: Build Rust libraries for iOS
        working-directory: modules/veloqrs/rust
        run: |
          echo "=== Building veloqrs for iOS ==="

          # Build for all iOS architectures
          for target in aarch64-apple-ios aarch64-apple-ios-sim x86_64-apple-ios; do
            echo "Building for $target..."
            cargo build --release --target $target -p veloqrs
          done

          # Create fat library for simulator (arm64 + x86_64)
          # Library is renamed to veloqrs_ffi to match podspec -lveloqrs_ffi
          echo "Creating fat library for simulator..."
          mkdir -p target/sim-fat
          lipo -create \
            target/aarch64-apple-ios-sim/release/libveloqrs.a \
            target/x86_64-apple-ios/release/libveloqrs.a \
            -output target/sim-fat/libveloqrs_ffi.a

          # Copy device library with correct name
          cp target/aarch64-apple-ios/release/libveloqrs.a target/aarch64-apple-ios/release/libveloqrs_ffi.a

          # Create XCFramework
          echo "Creating XCFramework..."
          mkdir -p ../ios/Frameworks
          rm -rf ../ios/Frameworks/VeloqrsFFI.xcframework

          xcodebuild -create-xcframework \
            -library target/aarch64-apple-ios/release/libveloqrs_ffi.a \
            -library target/sim-fat/libveloqrs_ffi.a \
            -output ../ios/Frameworks/VeloqrsFFI.xcframework

          echo "âœ“ XCFramework created"
          ls -la ../ios/Frameworks/

      - name: Build Rust for host (binding generation)
        working-directory: modules/veloqrs/rust
        run: |
          # Build for macOS host to generate bindings
          cargo build --release -p veloqrs
          echo "âœ“ Built for host platform"

      - name: Generate UniFFI bindings for iOS
        working-directory: modules/veloqrs/rust
        run: |
          echo "=== Generating UniFFI C++/TypeScript bindings ==="
          # Use 'jsi bindings' to avoid overwriting custom index.ts
          npx uniffi-bindgen-react-native generate jsi bindings \
            --ts-dir ../src/generated \
            --cpp-dir ../cpp/generated \
            --library \
            target/release/libveloqrs.dylib
          echo "âœ“ Generated bindings"

          # Save custom iOS files BEFORE turbo-module generation (it overwrites them)
          cp ../ios/Veloqrs.h ../ios/Veloqrs.h.custom
          cp ../ios/Veloqrs.mm ../ios/Veloqrs.mm.custom

          # Generate turbo-module wrapper files (cpp/veloqrs.h, cpp/veloqrs.cpp)
          # Note: This also generates ios/Veloqrs.{h,mm} which we don't want
          cd .. && npx uniffi-bindgen-react-native generate jsi turbo-module veloqrs
          echo "âœ“ Generated turbo-module wrapper"

          # Restore custom iOS files (the generated ones use NativeVeloqrsSpec which isn't available)
          mv ios/Veloqrs.h.custom ios/Veloqrs.h
          mv ios/Veloqrs.mm.custom ios/Veloqrs.mm
          echo "âœ“ Restored custom iOS files"

          ls -la cpp/ cpp/generated/

      - name: Copy C++ files for iOS build
        run: |
          # Copy C++ files into module ios/cpp/ where CocoaPods can find them
          # IMPORTANT: Keep generated/ subdirectory to avoid file name conflicts
          mkdir -p modules/veloqrs/ios/cpp/generated
          # Turbo module files (wrapper that includes generated bindings)
          cp modules/veloqrs/cpp/veloqrs.h modules/veloqrs/ios/cpp/
          cp modules/veloqrs/cpp/veloqrs.cpp modules/veloqrs/ios/cpp/
          # Generated bindings (must stay in generated/ subdirectory)
          cp modules/veloqrs/cpp/generated/veloqrs.hpp modules/veloqrs/ios/cpp/generated/
          cp modules/veloqrs/cpp/generated/veloqrs.cpp modules/veloqrs/ios/cpp/generated/
          echo "âœ“ Copied C++ files to module ios/cpp/"
          ls -la modules/veloqrs/ios/cpp/
          ls -la modules/veloqrs/ios/cpp/generated/

      # Verify C++ files exist before proceeding (safety check)
      - name: Verify C++ bindings exist
        run: |
          echo "=== Verifying C++ bindings ==="
          MISSING=""
          [ ! -f "modules/veloqrs/cpp/veloqrs.h" ] && MISSING="$MISSING cpp/veloqrs.h"
          [ ! -f "modules/veloqrs/cpp/veloqrs.cpp" ] && MISSING="$MISSING cpp/veloqrs.cpp"
          [ ! -f "modules/veloqrs/cpp/generated/veloqrs.hpp" ] && MISSING="$MISSING cpp/generated/veloqrs.hpp"
          [ ! -f "modules/veloqrs/cpp/generated/veloqrs.cpp" ] && MISSING="$MISSING cpp/generated/veloqrs.cpp"
          [ ! -f "modules/veloqrs/ios/cpp/veloqrs.h" ] && MISSING="$MISSING ios/cpp/veloqrs.h"
          [ ! -f "modules/veloqrs/ios/cpp/veloqrs.cpp" ] && MISSING="$MISSING ios/cpp/veloqrs.cpp"
          if [ -n "$MISSING" ]; then
            echo "::error::Missing C++ files:$MISSING"
            echo "This indicates binding generation failed. Check the 'Generate UniFFI bindings for iOS' step."
            exit 1
          fi
          echo "âœ“ All C++ bindings present"

      - name: Cache iOS prebuild
        id: ios-prebuild-cache
        uses: actions/cache@v4
        with:
          path: ios
          # v5: include modules/**/package.json for codegenConfig changes
          key: ios-prebuild-v5-${{ runner.os }}-${{ hashFiles('app.json', 'package.json', 'package-lock.json', 'plugins/**', 'expo-modules/**/*.json', 'modules/**/ios/**', 'modules/**/package.json') }}
          restore-keys: |
            ios-prebuild-v5-${{ runner.os }}-

      # ============================================
      # iOS Build
      # ============================================
      - name: Install dependencies
        run: npm ci

      - name: Generate native project
        if: steps.ios-prebuild-cache.outputs.cache-hit != 'true'
        run: npx expo prebuild --platform ios

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ios/Pods
            ~/Library/Caches/CocoaPods
          key: cocoapods-${{ runner.os }}-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            cocoapods-${{ runner.os }}-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true
          working-directory: config/fastlane

      - name: Install Pods
        working-directory: ios
        run: |
          # Always run pod install - it's fast if nothing changed and ensures consistency
          # This handles cases where prebuild cache hit but pods are stale
          pod install

      # ============================================
      # iOS Signing (for IPA builds on main)
      # ============================================
      - name: Check for iOS signing credentials
        id: check_ios_signing
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          IOS_DISTRIBUTION_CERT_P12: ${{ secrets.IOS_DISTRIBUTION_CERT_P12 }}
        run: |
          if [ -n "$MATCH_GIT_URL" ] && [ -n "$ASC_KEY_ID" ] && [ -n "$IOS_DISTRIBUTION_CERT_P12" ]; then
            echo "has_signing=true" >> $GITHUB_OUTPUT
            echo "âœ… iOS signing credentials found"
          else
            echo "has_signing=false" >> $GITHUB_OUTPUT
            echo "::notice::iOS signing not configured - skipping IPA build"
          fi

      # Import certificate via Apple-Actions (fixes codesign hanging issue)
      # See: https://github.com/orgs/community/discussions/70145
      - name: Import code signing certificate
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.IOS_DISTRIBUTION_CERT_P12 }}
          p12-password: ${{ secrets.IOS_DISTRIBUTION_CERT_PASSWORD }}

      - name: Setup SSH for Match
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.MATCH_SSH_PRIVATE_KEY }}

      # Match now only syncs provisioning profiles (certificate imported above)
      - name: Sync provisioning profiles with Match
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        working-directory: config/fastlane
        run: bundle exec fastlane match appstore --readonly

      # Pre-build diagnostics to help debug signing issues
      - name: Pre-build diagnostics
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          echo "=== Pre-build Diagnostics ==="

          echo "--- System Info ---"
          sw_vers
          xcodebuild -version

          echo "--- Disk Space ---"
          df -h /

          echo "--- Memory ---"
          vm_stat | head -5

          echo "--- Network: Testing Apple timestamp server connectivity ---"
          # This is the server codesign contacts for timestamps
          curl -sI --connect-timeout 5 https://timestamp.apple.com/ts01 && echo "âœ… timestamp.apple.com reachable" || echo "âš ï¸ timestamp.apple.com NOT reachable (--timestamp=none should help)"

          echo "--- Network: Testing Apple Developer services ---"
          curl -sI --connect-timeout 5 https://developer.apple.com && echo "âœ… developer.apple.com reachable" || echo "âš ï¸ developer.apple.com NOT reachable"

          echo "--- Keychain: Signing identities ---"
          security find-identity -v -p codesigning | head -10

          echo "--- Checking for codesign binary ---"
          which codesign
          codesign --version 2>&1 || echo "codesign version not available"

          echo "--- MapLibre framework location ---"
          find ios/Pods -name "MapLibre*.framework" -o -name "Mapbox*.framework" 2>/dev/null | head -5 || echo "MapLibre not in Pods yet"

          echo "=== End Pre-build Diagnostics ==="

      # Start watchdog to print diagnostics if build goes silent
      - name: Start build watchdog
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          # Aggressive watchdog: checks every 60 seconds, detailed codesign monitoring
          (
            sleep 60  # First check after 1 minute
            while true; do
              echo ""
              echo "========== WATCHDOG: $(date) =========="

              echo "--- Active processes (xcodebuild, codesign, security) ---"
              ps aux | grep -E 'xcodebuild|codesign|security' | grep -v grep || echo "No relevant processes"

              echo "--- Codesign processes with full command line ---"
              pgrep -fl codesign 2>/dev/null || echo "No codesign running"

              echo "--- Open network connections from codesign ---"
              lsof -i -n -P 2>/dev/null | grep -i codesign || echo "No codesign network connections"

              echo "--- System load ---"
              uptime

              echo "--- Memory pressure ---"
              memory_pressure 2>/dev/null || vm_stat | head -5

              echo "--- Disk usage ---"
              df -h / | tail -1

              echo "--- Last 20 lines of build log ---"
              tail -20 config/fastlane/artifacts/Veloq-Veloq.log 2>/dev/null || echo "No log yet"

              echo "--- Checking for stuck codesign (running > 2 min) ---"
              ps -eo pid,etime,command | grep codesign | grep -v grep || echo "No codesign process"

              echo "========================================"
              sleep 60  # Check every minute
            done
          ) &
          echo $! > /tmp/watchdog.pid
          echo "Watchdog started with PID $(cat /tmp/watchdog.pid) - checking every 60s"

      - name: Build signed IPA
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        timeout-minutes: 45
        env:
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          FASTLANE_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
        working-directory: config/fastlane
        run: |
          echo "=== Starting IPA build at $(date) ==="
          echo "Build will use OTHER_CODE_SIGN_FLAGS='--timestamp=none' to avoid timestamp server hangs"
          echo "--- Starting fastlane ---"
          bundle exec fastlane ios build_release
          echo "=== Build completed at $(date) ==="

      - name: Stop watchdog
        if: always() && steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          if [ -f /tmp/watchdog.pid ]; then
            kill $(cat /tmp/watchdog.pid) 2>/dev/null || true
            echo "Watchdog stopped"
          fi

      - name: Capture diagnostic info on failure
        if: failure() && steps.check_ios_signing.outputs.has_signing == 'true'
        run: |
          echo "=== Capturing failure diagnostics ==="
          mkdir -p config/fastlane/artifacts/diagnostics

          echo "--- Final process state ---" > config/fastlane/artifacts/diagnostics/processes.txt
          ps aux >> config/fastlane/artifacts/diagnostics/processes.txt 2>&1

          echo "--- Codesign processes ---" > config/fastlane/artifacts/diagnostics/codesign.txt
          pgrep -fl codesign >> config/fastlane/artifacts/diagnostics/codesign.txt 2>&1 || echo "No codesign" >> config/fastlane/artifacts/diagnostics/codesign.txt

          echo "--- Network connections ---" > config/fastlane/artifacts/diagnostics/network.txt
          lsof -i -n -P >> config/fastlane/artifacts/diagnostics/network.txt 2>&1 || echo "lsof failed" >> config/fastlane/artifacts/diagnostics/network.txt

          echo "--- System log (last 100 lines) ---" > config/fastlane/artifacts/diagnostics/system.log
          log show --last 5m --predicate 'process == "codesign" OR process == "xcodebuild"' >> config/fastlane/artifacts/diagnostics/system.log 2>&1 || echo "log show failed" >> config/fastlane/artifacts/diagnostics/system.log

          echo "--- Keychain state ---" > config/fastlane/artifacts/diagnostics/keychain.txt
          security list-keychains >> config/fastlane/artifacts/diagnostics/keychain.txt 2>&1
          security find-identity -v -p codesigning >> config/fastlane/artifacts/diagnostics/keychain.txt 2>&1

          echo "--- Memory state ---" > config/fastlane/artifacts/diagnostics/memory.txt
          vm_stat >> config/fastlane/artifacts/diagnostics/memory.txt 2>&1
          top -l 1 -n 10 >> config/fastlane/artifacts/diagnostics/memory.txt 2>&1

          echo "=== Diagnostics captured ==="

      - name: Upload build logs on failure
        if: failure() && steps.check_ios_signing.outputs.has_signing == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-logs-${{ steps.version.outputs.filename }}
          path: |
            config/fastlane/artifacts/*.log
            config/fastlane/artifacts/diagnostics/*
            ~/Library/Logs/gym/*.log
          retention-days: 7

      - name: Rename IPA
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          mkdir -p artifacts
          IPA_PATH=$(find . -name "*.ipa" -type f | head -1)
          if [ -n "$IPA_PATH" ]; then
            cp "$IPA_PATH" "artifacts/${{ steps.version.outputs.filename }}.ipa"
            echo "âœ… IPA: ${{ steps.version.outputs.filename }}.ipa"
          fi

      - name: Verify IPA code signature
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        env:
          EXPECTED_TEAM_ID: ${{ secrets.FASTLANE_TEAM_ID }}
          EXPECTED_BUNDLE_ID: "com.veloq.app"
        run: |
          echo "=== Verifying IPA code signature ==="
          IPA_FILE="artifacts/${{ steps.version.outputs.filename }}.ipa"

          if [ ! -f "$IPA_FILE" ]; then
            echo "::error::IPA file not found at $IPA_FILE"
            exit 1
          fi

          # Extract IPA
          rm -rf /tmp/ipa_verify
          mkdir -p /tmp/ipa_verify
          unzip -q "$IPA_FILE" -d /tmp/ipa_verify

          # Find .app bundle
          APP_PATH=$(find /tmp/ipa_verify -name "*.app" -type d | head -1)
          if [ -z "$APP_PATH" ]; then
            echo "::error::No .app bundle found in IPA"
            exit 1
          fi

          echo "Found app: $APP_PATH"

          # Verify code signature
          echo "--- Code Signature Details ---"
          codesign -dv --verbose=2 "$APP_PATH" 2>&1 | tee /tmp/codesign.txt || {
            echo "::error::IPA is not properly signed"
            exit 1
          }

          # Extract and verify Team ID
          ACTUAL_TEAM=$(grep "TeamIdentifier=" /tmp/codesign.txt | cut -d= -f2)
          echo "Expected Team ID: $EXPECTED_TEAM_ID"
          echo "Actual Team ID:   $ACTUAL_TEAM"

          if [ "$ACTUAL_TEAM" != "$EXPECTED_TEAM_ID" ]; then
            echo "::error::Team ID mismatch! Expected $EXPECTED_TEAM_ID but got $ACTUAL_TEAM"
            exit 1
          fi

          # Extract and verify Bundle ID from Info.plist
          ACTUAL_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print CFBundleIdentifier" "$APP_PATH/Info.plist" 2>/dev/null)
          echo "Expected Bundle ID: $EXPECTED_BUNDLE_ID"
          echo "Actual Bundle ID:   $ACTUAL_BUNDLE_ID"

          if [ "$ACTUAL_BUNDLE_ID" != "$EXPECTED_BUNDLE_ID" ]; then
            echo "::error::Bundle ID mismatch! Expected $EXPECTED_BUNDLE_ID but got $ACTUAL_BUNDLE_ID"
            exit 1
          fi

          # Verify signature is valid
          codesign --verify --deep --strict "$APP_PATH" 2>&1 || {
            echo "::error::Code signature verification failed"
            exit 1
          }

          # Cleanup
          rm -rf /tmp/ipa_verify

          echo "âœ… IPA signed correctly by team $ACTUAL_TEAM with bundle ID $ACTUAL_BUNDLE_ID"

      - name: Upload IPA artifact
        if: steps.check_ios_signing.outputs.has_signing == 'true' && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa-${{ steps.version.outputs.filename }}
          path: artifacts/*.ipa
          retention-days: 30

