/**
 * FFI Binding Sync Validation Tests
 *
 * These tests validate that the Swift wrapper code in RouteMatcherModule.swift
 * is in sync with the Kotlin generated bindings (which are the source of truth
 * for what the Rust FFI expects).
 *
 * This catches bugs like the iOS build failure where Swift was passing 6 params
 * to SectionConfig() but Rust/Kotlin expected 10.
 *
 * Runs on Linux CI without needing macOS/Xcode.
 */

import * as fs from 'fs';
import * as path from 'path';

const KOTLIN_BINDING_PATH = path.resolve(
  __dirname,
  '../../../modules/route-matcher-native/android/src/main/java/uniffi/route_matcher/route_matcher.kt'
);

const SWIFT_MODULE_PATH = path.resolve(
  __dirname,
  '../../../modules/route-matcher-native/ios/RouteMatcherModule.swift'
);

interface StructField {
  name: string;
  type: string;
}

interface StructDefinition {
  name: string;
  fields: StructField[];
}

/**
 * Parse Kotlin data class definitions from the generated bindings.
 * These are auto-generated by uniffi and represent the Rust struct schema.
 */
function parseKotlinDataClasses(content: string): Map<string, StructDefinition> {
  const structs = new Map<string, StructDefinition>();

  // Match data class definitions with their fields
  // Pattern: data class ClassName (\n    var `fieldName`: kotlin.Type\n    , ...)\n
  const classPattern = /data class (\w+) \(\s*([\s\S]*?)\)\s*\{/g;

  let match;
  while ((match = classPattern.exec(content)) !== null) {
    const className = match[1];
    const fieldsBlock = match[2];

    // Parse individual fields: var `fieldName`: kotlin.Type
    const fieldPattern = /var `(\w+)`: ([\w.<>]+)/g;
    const fields: StructField[] = [];

    let fieldMatch;
    while ((fieldMatch = fieldPattern.exec(fieldsBlock)) !== null) {
      fields.push({
        name: fieldMatch[1],
        type: fieldMatch[2],
      });
    }

    if (fields.length > 0) {
      structs.set(className, { name: className, fields });
    }
  }

  return structs;
}

/**
 * Parse Swift constructor calls from RouteMatcherModule.swift.
 * Extracts the parameter names passed to struct initializers.
 */
function parseSwiftConstructorCalls(content: string, structName: string): string[] {
  // Find all occurrences of StructName( and extract until balanced )
  const startPattern = new RegExp(`${structName}\\(`, 'g');
  let bestMatch: string[] = [];

  let startMatch;
  while ((startMatch = startPattern.exec(content)) !== null) {
    const startIdx = startMatch.index + startMatch[0].length;

    // Find the matching closing paren by counting depth
    let depth = 1;
    let endIdx = startIdx;
    while (depth > 0 && endIdx < content.length) {
      if (content[endIdx] === '(') depth++;
      else if (content[endIdx] === ')') depth--;
      endIdx++;
    }

    const paramsBlock = content.slice(startIdx, endIdx - 1);

    // Extract parameter names: paramName: followed by anything until , or end
    // Swift named params look like: paramName: value, or paramName: value)
    const paramPattern = /^\s*(\w+):/gm;
    const params: string[] = [];

    let paramMatch;
    while ((paramMatch = paramPattern.exec(paramsBlock)) !== null) {
      params.push(paramMatch[1]);
    }

    if (params.length > bestMatch.length) {
      bestMatch = params;
    }
  }

  return bestMatch;
}

/**
 * Convert Kotlin camelCase field names to what Swift uses.
 * Kotlin: proximityThreshold -> Swift: proximityThreshold (same)
 */
function kotlinToSwiftFieldName(kotlinName: string): string {
  // UniFFI uses the same camelCase names in both languages
  return kotlinName;
}

describe('FFI Binding Sync', () => {
  let kotlinContent: string;
  let swiftContent: string;
  let kotlinStructs: Map<string, StructDefinition>;

  beforeAll(() => {
    kotlinContent = fs.readFileSync(KOTLIN_BINDING_PATH, 'utf-8');
    swiftContent = fs.readFileSync(SWIFT_MODULE_PATH, 'utf-8');
    kotlinStructs = parseKotlinDataClasses(kotlinContent);
  });

  describe('SectionConfig', () => {
    it('should have SectionConfig defined in Kotlin bindings', () => {
      expect(kotlinStructs.has('SectionConfig')).toBe(true);
    });

    it('should have all Kotlin SectionConfig fields in Swift constructor', () => {
      const kotlinDef = kotlinStructs.get('SectionConfig');
      expect(kotlinDef).toBeDefined();

      const kotlinFields = kotlinDef!.fields.map((f) => f.name);
      const swiftParams = parseSwiftConstructorCalls(swiftContent, 'SectionConfig');

      // This is the critical test - Swift must pass ALL fields that Kotlin expects
      expect(swiftParams.length).toBe(kotlinFields.length);

      // Verify each Kotlin field has a corresponding Swift parameter
      for (const kotlinField of kotlinFields) {
        const swiftField = kotlinToSwiftFieldName(kotlinField);
        expect(swiftParams).toContain(swiftField);
      }
    });

    it('should have correct field count (currently 10)', () => {
      const kotlinDef = kotlinStructs.get('SectionConfig');
      expect(kotlinDef?.fields.length).toBe(10);

      const swiftParams = parseSwiftConstructorCalls(swiftContent, 'SectionConfig');
      expect(swiftParams.length).toBe(10);
    });

    it('should include new detection mode fields', () => {
      // These were the missing fields that broke the iOS build
      const swiftParams = parseSwiftConstructorCalls(swiftContent, 'SectionConfig');

      expect(swiftParams).toContain('detectionMode');
      expect(swiftParams).toContain('includePotentials');
      expect(swiftParams).toContain('scalePresets');
      expect(swiftParams).toContain('preserveHierarchy');
    });
  });

  describe('ScalePreset', () => {
    it('should have ScalePreset defined in Kotlin bindings', () => {
      expect(kotlinStructs.has('ScalePreset')).toBe(true);
    });

    it('should have all Kotlin ScalePreset fields in Swift constructor', () => {
      const kotlinDef = kotlinStructs.get('ScalePreset');
      expect(kotlinDef).toBeDefined();

      const kotlinFields = kotlinDef!.fields.map((f) => f.name);
      const swiftParams = parseSwiftConstructorCalls(swiftContent, 'ScalePreset');

      expect(swiftParams.length).toBe(kotlinFields.length);

      for (const kotlinField of kotlinFields) {
        const swiftField = kotlinToSwiftFieldName(kotlinField);
        expect(swiftParams).toContain(swiftField);
      }
    });

    it('should have correct field count (currently 4)', () => {
      const kotlinDef = kotlinStructs.get('ScalePreset');
      expect(kotlinDef?.fields.length).toBe(4);

      const swiftParams = parseSwiftConstructorCalls(swiftContent, 'ScalePreset');
      expect(swiftParams.length).toBe(4);
    });
  });

  describe('MatchConfig', () => {
    it('should have MatchConfig defined in Kotlin bindings', () => {
      expect(kotlinStructs.has('MatchConfig')).toBe(true);
    });

    it('should have all Kotlin MatchConfig fields in Swift constructor', () => {
      const kotlinDef = kotlinStructs.get('MatchConfig');
      if (!kotlinDef) {
        // MatchConfig might not be in this file, skip if not found
        return;
      }

      const kotlinFields = kotlinDef.fields.map((f) => f.name);
      const swiftParams = parseSwiftConstructorCalls(swiftContent, 'MatchConfig');

      if (swiftParams.length > 0) {
        expect(swiftParams.length).toBe(kotlinFields.length);
      }
    });
  });

  describe('Binding file existence', () => {
    it('Kotlin binding file should exist', () => {
      expect(fs.existsSync(KOTLIN_BINDING_PATH)).toBe(true);
    });

    it('Swift module file should exist', () => {
      expect(fs.existsSync(SWIFT_MODULE_PATH)).toBe(true);
    });

    it('Kotlin binding should be substantial (not empty/stub)', () => {
      const stats = fs.statSync(KOTLIN_BINDING_PATH);
      // The generated Kotlin binding is ~238KB
      expect(stats.size).toBeGreaterThan(100000);
    });
  });

  describe('Critical structs are parseable', () => {
    it('should parse multiple data classes from Kotlin', () => {
      // We expect at least these structs to be defined as data classes
      // Note: Some types like Coordinate may be defined differently
      const expectedStructs = [
        'RouteSignature',
        'MatchResult',
        'SectionConfig',
        'ScalePreset',
        'FrequentSection',
        'MatchConfig',
      ];

      for (const structName of expectedStructs) {
        expect(kotlinStructs.has(structName)).toBe(true);
      }
    });

    it('should parse at least 10 data classes', () => {
      // The generated Kotlin has many data classes
      expect(kotlinStructs.size).toBeGreaterThanOrEqual(10);
    });
  });
});

/**
 * Helper to generate a report of all struct field mismatches.
 * Useful for debugging when the test fails.
 */
export function generateBindingSyncReport(): string {
  const kotlinContent = fs.readFileSync(KOTLIN_BINDING_PATH, 'utf-8');
  const swiftContent = fs.readFileSync(SWIFT_MODULE_PATH, 'utf-8');
  const kotlinStructs = parseKotlinDataClasses(kotlinContent);

  const lines: string[] = ['# FFI Binding Sync Report\n'];

  for (const [name, def] of kotlinStructs) {
    const kotlinFields = def.fields.map((f) => f.name);
    const swiftParams = parseSwiftConstructorCalls(swiftContent, name);

    if (swiftParams.length === 0) {
      lines.push(`## ${name}: Not found in Swift wrapper`);
      continue;
    }

    const missingInSwift = kotlinFields.filter((f) => !swiftParams.includes(f));
    const extraInSwift = swiftParams.filter((f) => !kotlinFields.includes(f));

    if (missingInSwift.length > 0 || extraInSwift.length > 0) {
      lines.push(`## ${name}: MISMATCH`);
      lines.push(`  Kotlin fields (${kotlinFields.length}): ${kotlinFields.join(', ')}`);
      lines.push(`  Swift params (${swiftParams.length}): ${swiftParams.join(', ')}`);
      if (missingInSwift.length > 0) {
        lines.push(`  Missing in Swift: ${missingInSwift.join(', ')}`);
      }
      if (extraInSwift.length > 0) {
        lines.push(`  Extra in Swift: ${extraInSwift.join(', ')}`);
      }
    } else {
      lines.push(`## ${name}: OK (${kotlinFields.length} fields)`);
    }
    lines.push('');
  }

  return lines.join('\n');
}
